diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index f2f7c6c..9be4201 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -12,6 +12,7 @@
 #define _ASM_CHECKSUM_H
 
 #include <linux/in6.h>
+#include <linux/unaligned/packed_struct.h>
 
 #include <asm/uaccess.h>
 
@@ -104,26 +105,30 @@ static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
 	const unsigned int *stop = word + ihl;
 	unsigned int csum;
 	int carry;
+	unsigned int w;
 
-	csum = word[0];
-	csum += word[1];
-	carry = (csum < word[1]);
+	csum = __get_unaligned_cpu32(word++);
+
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[2];
-	carry = (csum < word[2]);
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[3];
-	carry = (csum < word[3]);
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	word += 4;
 	do {
-		csum += *word;
-		carry = (csum < *word);
+		w = __get_unaligned_cpu32(word++);
+		csum += w;
+		carry = (csum < w);
 		csum += carry;
-		word++;
 	} while (word != stop);
 
 	return csum_fold(csum);
diff --git a/include/net/inet_ecn.h b/include/net/inet_ecn.h
index aab7375..e5e9f46 100644
--- a/include/net/inet_ecn.h
+++ b/include/net/inet_ecn.h
@@ -113,15 +113,21 @@ struct ipv6hdr;
 
 static inline int IP6_ECN_set_ce(struct ipv6hdr *iph)
 {
+	__be32 dsfield;
 	if (INET_ECN_is_not_ect(ipv6_get_dsfield(iph)))
 		return 0;
-	*(__be32*)iph |= htonl(INET_ECN_CE << 20);
+	dsfield = __get_unaligned_cpu32((__be32*)iph);
+	dsfield |= htonl(INET_ECN_CE << 20);
+	__put_unaligned_cpu32(dsfield, (__be32*)iph);
 	return 1;
 }
 
 static inline void IP6_ECN_clear(struct ipv6hdr *iph)
 {
-	*(__be32*)iph &= ~htonl(INET_ECN_MASK << 20);
+	__be32 dsfield;
+	dsfield = __get_unaligned_cpu32((__be32*)iph);
+	dsfield &= ~htonl(INET_ECN_MASK << 20);
+	__put_unaligned_cpu32(dsfield, (__be32*)iph);
 }
 
 static inline void ipv6_copy_dscp(unsigned int dscp, struct ipv6hdr *inner)
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index 979bf6c..d7a4412 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -106,7 +106,7 @@ struct frag_hdr {
 	__u8	reserved;
 	__be16	frag_off;
 	__be32	identification;
-};
+} __packed;
 
 #define	IP6_MF	0x0001
 
@@ -384,7 +384,7 @@ static inline bool __ipv6_prefix_equal(const __be32 *a1, const __be32 *a2,
 
 	/* check incomplete u32 in prefix */
 	pbi = prefixlen & 0x1f;
-	if (pbi && ((a1[pdw] ^ a2[pdw]) & htonl((0xffffffff) << (32 - pbi))))
+	if (pbi && ((__get_unaligned_cpu32(&a1[pdw]) ^ __get_unaligned_cpu32(&a2[pdw])) & htonl((0xffffffff) << (32 - pbi))))
 		return false;
 
 	return true;
@@ -506,7 +506,7 @@ static inline int __ipv6_addr_diff(const void *token1, const void *token2, int a
 	addrlen >>= 2;
 
 	for (i = 0; i < addrlen; i++) {
-		__be32 xb = a1[i] ^ a2[i];
+		__be32 xb = __get_unaligned_cpu32(&a1[i]) ^ __get_unaligned_cpu32(&a2[i]);
 		if (xb)
 			return i * 32 + 31 - __fls(ntohl(xb));
 	}
diff --git a/include/net/ndisc.h b/include/net/ndisc.h
index 980d263..7a1aa60 100644
--- a/include/net/ndisc.h
+++ b/include/net/ndisc.h
@@ -65,18 +65,18 @@ struct nd_msg {
         struct icmp6hdr	icmph;
         struct in6_addr	target;
 	__u8		opt[0];
-};
+} __packed;
 
 struct rs_msg {
 	struct icmp6hdr	icmph;
 	__u8		opt[0];
-};
+} __packed;
 
 struct ra_msg {
         struct icmp6hdr		icmph;
 	__be32			reachable_time;
 	__be32			retrans_timer;
-};
+} __packed;
 
 struct nd_opt_hdr {
 	__u8		nd_opt_type;
@@ -135,10 +135,10 @@ static inline u32 ndisc_hashfn(const void *pkey, const struct net_device *dev, _
 {
 	const u32 *p32 = pkey;
 
-	return (((p32[0] ^ hash32_ptr(dev)) * hash_rnd[0]) +
-		(p32[1] * hash_rnd[1]) +
-		(p32[2] * hash_rnd[2]) +
-		(p32[3] * hash_rnd[3]));
+	return (((__get_unaligned_cpu32(&p32[0]) ^ hash32_ptr(dev)) * hash_rnd[0]) +
+		(__get_unaligned_cpu32(&p32[1]) * hash_rnd[1]) +
+		(__get_unaligned_cpu32(&p32[2]) * hash_rnd[2]) +
+		(__get_unaligned_cpu32(&p32[3]) * hash_rnd[3]));
 }
 
 static inline struct neighbour *__ipv6_neigh_lookup(struct neigh_table *tbl, struct net_device *dev, const void *pkey)
@@ -156,8 +156,8 @@ static inline struct neighbour *__ipv6_neigh_lookup(struct neigh_table *tbl, str
 	     n = rcu_dereference_bh(n->next)) {
 		u32 *n32 = (u32 *) n->primary_key;
 		if (n->dev == dev &&
-		    ((n32[0] ^ p32[0]) | (n32[1] ^ p32[1]) |
-		     (n32[2] ^ p32[2]) | (n32[3] ^ p32[3])) == 0) {
+		    ((n32[0] ^ __get_unaligned_cpu32(&p32[0])) | (n32[1] ^ __get_unaligned_cpu32(&p32[1])) |
+		     (n32[2] ^ __get_unaligned_cpu32(&p32[2])) | (n32[3] ^ __get_unaligned_cpu32(&p32[3]))) == 0) {
 			if (!atomic_inc_not_zero(&n->refcnt))
 				n = NULL;
 			break;
diff --git a/include/uapi/linux/icmp.h b/include/uapi/linux/icmp.h
index 16fff05..9e453b5 100644
--- a/include/uapi/linux/icmp.h
+++ b/include/uapi/linux/icmp.h
@@ -80,7 +80,7 @@ struct icmphdr {
 		__be16	mtu;
 	} frag;
   } un;
-};
+} __packed;
 
 
 /*
diff --git a/include/uapi/linux/icmpv6.h b/include/uapi/linux/icmpv6.h
index e0133c7..5b113ff 100644
--- a/include/uapi/linux/icmpv6.h
+++ b/include/uapi/linux/icmpv6.h
@@ -76,7 +76,7 @@ struct icmp6hdr {
 #define icmp6_addrconf_other	icmp6_dataun.u_nd_ra.other
 #define icmp6_rt_lifetime	icmp6_dataun.u_nd_ra.rt_lifetime
 #define icmp6_router_pref	icmp6_dataun.u_nd_ra.router_pref
-};
+} __packed;
 
 
 #define ICMPV6_ROUTER_PREF_LOW		0x3
diff --git a/include/uapi/linux/igmp.h b/include/uapi/linux/igmp.h
index ccbb32a..7818564 100644
--- a/include/uapi/linux/igmp.h
+++ b/include/uapi/linux/igmp.h
@@ -32,7 +32,7 @@ struct igmphdr {
 	__u8 code;		/* For newer IGMP */
 	__sum16 csum;
 	__be32 group;
-};
+} __packed;
 
 /* V3 group record types [grec_type] */
 #define IGMPV3_MODE_IS_INCLUDE		1
@@ -48,7 +48,7 @@ struct igmpv3_grec {
 	__be16	grec_nsrcs;
 	__be32	grec_mca;
 	__be32	grec_src[0];
-};
+} __packed;
 
 struct igmpv3_report {
 	__u8 type;
@@ -57,7 +57,7 @@ struct igmpv3_report {
 	__be16 resv2;
 	__be16 ngrec;
 	struct igmpv3_grec grec[0];
-};
+} __packed;
 
 struct igmpv3_query {
 	__u8 type;
@@ -78,7 +78,7 @@ struct igmpv3_query {
 	__u8 qqic;
 	__be16 nsrcs;
 	__be32 srcs[0];
-};
+} __packed;
 
 #define IGMP_HOST_MEMBERSHIP_QUERY	0x11	/* From RFC1112 */
 #define IGMP_HOST_MEMBERSHIP_REPORT	0x12	/* Ditto */
diff --git a/include/uapi/linux/in.h b/include/uapi/linux/in.h
index 9edb441..280ddeb 100644
--- a/include/uapi/linux/in.h
+++ b/include/uapi/linux/in.h
@@ -55,7 +55,7 @@ enum {
 /* Internet address. */
 struct in_addr {
 	__be32	s_addr;
-};
+} __attribute__((packed));
 
 #define IP_TOS		1
 #define IP_TTL		2
diff --git a/include/uapi/linux/in6.h b/include/uapi/linux/in6.h
index 1e31599..aa9a3f2 100644
--- a/include/uapi/linux/in6.h
+++ b/include/uapi/linux/in6.h
@@ -36,7 +36,7 @@ struct in6_addr {
 #define s6_addr			in6_u.u6_addr8
 #define s6_addr16		in6_u.u6_addr16
 #define s6_addr32		in6_u.u6_addr32
-};
+} __attribute__((packed));
 
 /* IPv6 Wildcard Address (::) and Loopback Address (::1) defined in RFC2553
  * NOTE: Be aware the IN6ADDR_* constants and in6addr_* externals are defined
diff --git a/include/uapi/linux/ip.h b/include/uapi/linux/ip.h
index 6cf06bf..fdf1110 100644
--- a/include/uapi/linux/ip.h
+++ b/include/uapi/linux/ip.h
@@ -102,7 +102,7 @@ struct iphdr {
 	__be32	saddr;
 	__be32	daddr;
 	/*The options start here. */
-};
+} __attribute__((packed)) __attribute__((aligned(2)));
 
 
 struct ip_auth_hdr {
@@ -112,25 +112,25 @@ struct ip_auth_hdr {
 	__be32 spi;
 	__be32 seq_no;		/* Sequence number */
 	__u8  auth_data[0];	/* Variable len but >=4. Mind the 64 bit alignment! */
-};
+} __attribute__((packed));
 
 struct ip_esp_hdr {
 	__be32 spi;
 	__be32 seq_no;		/* Sequence number */
 	__u8  enc_data[0];	/* Variable len but >=8. Mind the 64 bit alignment! */
-};
+} __attribute__((packed));
 
 struct ip_comp_hdr {
 	__u8 nexthdr;
 	__u8 flags;
 	__be16 cpi;
-};
+} __attribute__((packed));
 
 struct ip_beet_phdr {
 	__u8 nexthdr;
 	__u8 hdrlen;
 	__u8 padlen;
 	__u8 reserved;
-};
+} __attribute__((packed));
 
 #endif /* _UAPI_LINUX_IP_H */
diff --git a/include/uapi/linux/ipv6.h b/include/uapi/linux/ipv6.h
index a6d7d1c..66f6a44 100644
--- a/include/uapi/linux/ipv6.h
+++ b/include/uapi/linux/ipv6.h
@@ -49,8 +49,7 @@ struct ipv6_rt_hdr {
 	 *	type specific data
 	 *	variable length field
 	 */
-};
-
+} __attribute__((packed));
 
 struct ipv6_opt_hdr {
 	__u8 		nexthdr;
@@ -74,7 +73,7 @@ struct rt0_hdr {
 	struct in6_addr		addr[0];
 
 #define rt0_type		rt_hdr.type
-};
+} __attribute__((packed));
 
 /*
  *	routing header type 2
@@ -86,7 +85,7 @@ struct rt2_hdr {
 	struct in6_addr		addr;
 
 #define rt2_type		rt_hdr.type
-};
+} __attribute__((packed));
 
 /*
  *	home address option in destination options header
@@ -123,7 +122,7 @@ struct ipv6hdr {
 
 	struct	in6_addr	saddr;
 	struct	in6_addr	daddr;
-};
+} __attribute__((packed)) __attribute__((aligned(2)));
 
 
 /* index values for the variables in ipv6_devconf */
diff --git a/include/uapi/linux/tcp.h b/include/uapi/linux/tcp.h
index e962faa..4c8818e 100644
--- a/include/uapi/linux/tcp.h
+++ b/include/uapi/linux/tcp.h
@@ -54,7 +54,7 @@ struct tcphdr {
 	__be16	window;
 	__sum16	check;
 	__be16	urg_ptr;
-};
+} __attribute__((packed)) __attribute__((aligned(2)));
 
 /*
  *	The union cast uses a gcc extension to avoid aliasing problems
@@ -64,9 +64,10 @@ struct tcphdr {
 union tcp_word_hdr { 
 	struct tcphdr hdr;
 	__be32 		  words[5];
-}; 
+} __attribute__((packed));
 
-#define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
+#define tcp_flag_word2(tp) ( ((union tcp_word_hdr *)(tp))->words [3])
+#define tcp_flag_word(tp) ( __get_unaligned_cpu32(&(((union tcp_word_hdr *)(tp))->words [3])))
 
 enum { 
 	TCP_FLAG_CWR = __constant_cpu_to_be32(0x00800000),
diff --git a/include/uapi/linux/udp.h b/include/uapi/linux/udp.h
index e2bcfd7..c7eb65b 100644
--- a/include/uapi/linux/udp.h
+++ b/include/uapi/linux/udp.h
@@ -24,7 +24,7 @@ struct udphdr {
 	__be16	dest;
 	__be16	len;
 	__sum16	check;
-};
+} __attribute__((packed)) __attribute__((aligned(2)));
 
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
diff --git a/net/core/flow_dissector.c b/net/core/flow_dissector.c
index 466820b..f978bf9 100644
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@ -18,7 +18,10 @@ static void iph_to_flow_copy_addrs(struct flow_keys *flow, const struct iphdr *i
 {
 	BUILD_BUG_ON(offsetof(typeof(*flow), dst) !=
 		     offsetof(typeof(*flow), src) + sizeof(flow->src));
-	memcpy(&flow->src, &iph->saddr, sizeof(flow->src) + sizeof(flow->dst));
+	/*	memcpy(&flow->src, &iph->saddr, sizeof(flow->src) + sizeof(flow->dst)); */
+	flow->src = iph->saddr;
+	flow->dst = iph->daddr;
+
 }
 
 bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)
@@ -137,7 +140,7 @@ ipv6:
 		nhoff += poff;
 		ports = skb_header_pointer(skb, nhoff, sizeof(_ports), &_ports);
 		if (ports)
-			flow->ports = *ports;
+		  flow->ports = __get_unaligned_cpu32(ports);
 	}
 
 	return true;
diff --git a/net/core/secure_seq.c b/net/core/secure_seq.c
index e61a8bb..f7beb31 100644
--- a/net/core/secure_seq.c
+++ b/net/core/secure_seq.c
@@ -7,6 +7,7 @@
 #include <linux/hrtimer.h>
 #include <linux/ktime.h>
 #include <linux/string.h>
+#include <linux/unaligned/packed_struct.h>
 
 #include <net/secure_seq.h>
 
@@ -46,7 +47,7 @@ __u32 secure_tcpv6_sequence_number(const __be32 *saddr, const __be32 *daddr,
 
 	memcpy(hash, saddr, 16);
 	for (i = 0; i < 4; i++)
-		secret[i] = net_secret[i] + (__force u32)daddr[i];
+	  secret[i] = net_secret[i] + (__force u32) __get_unaligned_cpu32(&daddr[i]);
 	secret[4] = net_secret[4] +
 		(((__force u16)sport << 16) + (__force u16)dport);
 	for (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)
diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
index fcdd0c2..e8d93c8 100644
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@ -14,6 +14,7 @@
 #include <linux/skbuff.h>
 #include <linux/icmp.h>
 #include <linux/sysctl.h>
+#include <linux/unaligned/packed_struct.h>
 #include <net/route.h>
 #include <net/ip.h>
 
@@ -39,8 +40,8 @@ static bool ipv4_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,
 	if (ap == NULL)
 		return false;
 
-	tuple->src.u3.ip = ap[0];
-	tuple->dst.u3.ip = ap[1];
+	tuple->src.u3.ip = __get_unaligned_cpu32(ap++);
+	tuple->dst.u3.ip = __get_unaligned_cpu32(ap);
 
 	return true;
 }
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index e457c7a..55ec75c 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -3149,7 +3149,7 @@ found:
 
 	p = *head;
 	th2 = tcp_hdr(p);
-	tcp_flag_word(th2) |= flags & (TCP_FLAG_FIN | TCP_FLAG_PSH);
+	tcp_flag_word2(th2) = tcp_flag_word(th2) | flags & (TCP_FLAG_FIN | TCP_FLAG_PSH);
 
 out_check_final:
 	flush = len < mss;
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 181fc82..490d83e 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -3842,13 +3842,13 @@ static bool tcp_parse_aligned_timestamp(struct tcp_sock *tp, const struct tcphdr
 {
 	const __be32 *ptr = (const __be32 *)(th + 1);
 
-	if (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)
+	if (__get_unaligned_cpu32(ptr) == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)
 			  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {
 		tp->rx_opt.saw_tstamp = 1;
 		++ptr;
-		tp->rx_opt.rcv_tsval = ntohl(*ptr);
+		tp->rx_opt.rcv_tsval = ntohl(__get_unaligned_cpu32(ptr));
 		++ptr;
-		tp->rx_opt.rcv_tsecr = ntohl(*ptr);
+		tp->rx_opt.rcv_tsecr = ntohl(__get_unaligned_cpu32(ptr));
 		return true;
 	}
 	return false;
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index a974247..5e7721f 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -687,7 +687,7 @@ bool ipv6_opt_accepted(const struct sock *sk, const struct sk_buff *skb)
 		if ((opt->hop && (np->rxopt.bits.hopopts ||
 				  np->rxopt.bits.ohopopts)) ||
 		    ((IPV6_FLOWINFO_MASK &
-		      *(__be32 *)skb_network_header(skb)) &&
+		      __get_unaligned_cpu32((__be32 *)skb_network_header(skb))) &&
 		     np->rxopt.bits.rxflow) ||
 		    (opt->srcrt && (np->rxopt.bits.srcrt ||
 		     np->rxopt.bits.osrcrt)) ||
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index be2b67d6..6cbd2b7 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -360,12 +360,12 @@ int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len)
 				*(struct in6_addr *)(nh + serr->addr_offset);
 			if (np->sndflow)
 				sin->sin6_flowinfo =
-					(*(__be32 *)(nh + serr->addr_offset - 24) &
+					(__get_unaligned_cpu32((__be32 *)(nh + serr->addr_offset - 24)) &
 					 IPV6_FLOWINFO_MASK);
 			if (ipv6_addr_type(&sin->sin6_addr) & IPV6_ADDR_LINKLOCAL)
 				sin->sin6_scope_id = IP6CB(skb)->iif;
 		} else {
-			ipv6_addr_set_v4mapped(*(__be32 *)(nh + serr->addr_offset),
+			ipv6_addr_set_v4mapped(__get_unaligned_cpu32((__be32 *)(nh + serr->addr_offset)),
 					       &sin->sin6_addr);
 		}
 	}
@@ -492,8 +492,8 @@ int datagram_recv_ctl(struct sock *sk, struct msghdr *msg, struct sk_buff *skb)
 		put_cmsg(msg, SOL_IPV6, IPV6_TCLASS, sizeof(tclass), &tclass);
 	}
 
-	if (np->rxopt.bits.rxflow && (*(__be32 *)nh & IPV6_FLOWINFO_MASK)) {
-		__be32 flowinfo = *(__be32 *)nh & IPV6_FLOWINFO_MASK;
+	if (np->rxopt.bits.rxflow && (__get_unaligned_cpu32((__be32 *)nh) & IPV6_FLOWINFO_MASK)) {
+		__be32 flowinfo = __get_unaligned_cpu32((__be32 *)nh) & IPV6_FLOWINFO_MASK;
 		put_cmsg(msg, SOL_IPV6, IPV6_FLOWINFO, sizeof(flowinfo), &flowinfo);
 	}
 
@@ -588,7 +588,7 @@ int datagram_recv_ctl(struct sock *sk, struct msghdr *msg, struct sk_buff *skb)
 
 			sin6.sin6_family = AF_INET6;
 			sin6.sin6_addr = ipv6_hdr(skb)->daddr;
-			sin6.sin6_port = ports[1];
+			sin6.sin6_port = __get_unaligned_cpu16(&(ports[1]));
 			sin6.sin6_flowinfo = 0;
 			sin6.sin6_scope_id = 0;
 
@@ -680,12 +680,12 @@ int datagram_send_ctl(struct net *net, struct sock *sk,
 			}
 
 			if (fl6->flowlabel&IPV6_FLOWINFO_MASK) {
-				if ((fl6->flowlabel^*(__be32 *)CMSG_DATA(cmsg))&~IPV6_FLOWINFO_MASK) {
+				if ((fl6->flowlabel^__get_unaligned_cpu32((__be32 *)CMSG_DATA(cmsg)))&~IPV6_FLOWINFO_MASK) {
 					err = -EINVAL;
 					goto exit_f;
 				}
 			}
-			fl6->flowlabel = IPV6_FLOWINFO_MASK & *(__be32 *)CMSG_DATA(cmsg);
+			fl6->flowlabel = IPV6_FLOWINFO_MASK & __get_unaligned_cpu32((__be32 *)CMSG_DATA(cmsg));
 			break;
 
 		case IPV6_2292HOPOPTS:
diff --git a/net/ipv6/exthdrs.c b/net/ipv6/exthdrs.c
index fa3d9c3..fd0f487 100644
--- a/net/ipv6/exthdrs.c
+++ b/net/ipv6/exthdrs.c
@@ -622,7 +622,7 @@ static bool ipv6_hop_jumbo(struct sk_buff *skb, int optoff)
 		goto drop;
 	}
 
-	pkt_len = ntohl(*(__be32 *)(nh + optoff + 2));
+	pkt_len = ntohl(__get_unaligned_cpu32((__be32 *)(nh + optoff + 2)));
 	if (pkt_len <= IPV6_MAXPLEN) {
 		IP6_INC_STATS_BH(net, ipv6_skb_idev(skb),
 				 IPSTATS_MIB_INHDRERRORS);
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index 24995a9..ce8bd33 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -144,7 +144,7 @@ static __inline__ __be32 addr_bit_set(const void *token, int fn_bit)
 	 * See include/asm-generic/bitops/le.h.
 	 */
 	return (__force __be32)(1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)) &
-	       addr[fn_bit >> 5];
+	       __get_unaligned_cpu32(&addr[fn_bit >> 5]);
 }
 
 static __inline__ struct fib6_node * node_alloc(void)
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index aece3e7..95fb511 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -216,7 +216,9 @@ int ip6_xmit(struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,
 	if (hlimit < 0)
 		hlimit = ip6_dst_hoplimit(dst);
 
-	*(__be32 *)hdr = htonl(0x60000000 | (tclass << 20)) | fl6->flowlabel;
+	__put_unaligned_cpu32(htonl(0x60000000 | (tclass << 20))
+			      | fl6->flowlabel,
+		              (__be32*)hdr);
 
 	hdr->payload_len = htons(seg_len);
 	hdr->nexthdr = proto;
@@ -267,7 +269,7 @@ int ip6_nd_hdr(struct sock *sk, struct sk_buff *skb, struct net_device *dev,
 	skb_put(skb, sizeof(struct ipv6hdr));
 	hdr = ipv6_hdr(skb);
 
-	*(__be32*)hdr = htonl(0x60000000);
+	__put_unaligned_cpu32(htonl(0x60000000), (__be32*)hdr);
 
 	hdr->payload_len = htons(len);
 	hdr->nexthdr = proto;
@@ -1614,8 +1616,9 @@ int ip6_push_pending_frames(struct sock *sk)
 	skb_reset_network_header(skb);
 	hdr = ipv6_hdr(skb);
 
-	*(__be32*)hdr = fl6->flowlabel |
-		     htonl(0x60000000 | ((int)np->cork.tclass << 20));
+	__put_unaligned_cpu32(fl6->flowlabel |
+			      htonl(0x60000000 | ((int)np->cork.tclass << 20)),
+			      (__be32*)hdr);
 
 	hdr->hop_limit = np->cork.hop_limit;
 	hdr->nexthdr = proto;
diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c
index cb7e2de..856c241 100644
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@ -1004,7 +1004,7 @@ static int ip6_tnl_xmit2(struct sk_buff *skb,
 	skb_push(skb, sizeof(struct ipv6hdr));
 	skb_reset_network_header(skb);
 	ipv6h = ipv6_hdr(skb);
-	*(__be32*)ipv6h = fl6->flowlabel | htonl(0x60000000);
+	__put_unaligned_cpu32(fl6->flowlabel | htonl(0x60000000), (__be32*)ipv6h);
 	dsfield = INET_ECN_encapsulate(0, dsfield);
 	ipv6_change_dsfield(ipv6h, ~INET_ECN_MASK, dsfield);
 	ipv6h->hop_limit = t->parms.hop_limit;
@@ -1110,9 +1110,9 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	dsfield = ipv6_get_dsfield(ipv6h);
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
-		fl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_TCLASS_MASK);
+		fl6.flowlabel |= (__get_unaligned_cpu32((__be32 *) ipv6h) & IPV6_TCLASS_MASK);
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)
-		fl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_FLOWLABEL_MASK);
+		fl6.flowlabel |= (__get_unaligned_cpu32((__be32 *) ipv6h) & IPV6_FLOWLABEL_MASK);
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
 		fl6.flowi6_mark = skb->mark;
 
diff --git a/net/ipv6/reassembly.c b/net/ipv6/reassembly.c
index da8a4e3..8947ed1 100644
--- a/net/ipv6/reassembly.c
+++ b/net/ipv6/reassembly.c
@@ -124,10 +124,10 @@ void ip6_frag_init(struct inet_frag_queue *q, void *a)
 	struct frag_queue *fq = container_of(q, struct frag_queue, q);
 	struct ip6_create_arg *arg = a;
 
-	fq->id = arg->id;
-	fq->user = arg->user;
-	fq->saddr = *arg->src;
-	fq->daddr = *arg->dst;
+	fq->id = __get_unaligned_cpu32(&arg->id);
+	fq->user = __get_unaligned_cpu32(&arg->user);
+	memcpy(&fq->saddr, arg->src, sizeof(struct in6_addr));
+	memcpy(&fq->daddr, arg->dst, sizeof(struct in6_addr));
 }
 EXPORT_SYMBOL(ip6_frag_init);
 
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index b1e6cf0..bd010a8 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -938,7 +938,7 @@ void ip6_route_input(struct sk_buff *skb)
 		.flowi6_iif = skb->dev->ifindex,
 		.daddr = iph->daddr,
 		.saddr = iph->saddr,
-		.flowlabel = (* (__be32 *) iph) & IPV6_FLOWINFO_MASK,
+		.flowlabel = (__get_unaligned_cpu32(iph)) & IPV6_FLOWINFO_MASK,
 		.flowi6_mark = skb->mark,
 		.flowi6_proto = iph->nexthdr,
 	};
@@ -1108,7 +1108,7 @@ void ip6_update_pmtu(struct sk_buff *skb, struct net *net, __be32 mtu,
 	fl6.flowi6_flags = 0;
 	fl6.daddr = iph->daddr;
 	fl6.saddr = iph->saddr;
-	fl6.flowlabel = (*(__be32 *) iph) & IPV6_FLOWINFO_MASK;
+	fl6.flowlabel = __get_unaligned_cpu32((__be32 *) iph) & IPV6_FLOWINFO_MASK;
 
 	dst = ip6_route_output(net, NULL, &fl6);
 	if (!dst->error)
@@ -1136,7 +1136,7 @@ void ip6_redirect(struct sk_buff *skb, struct net *net, int oif, u32 mark)
 	fl6.flowi6_flags = 0;
 	fl6.daddr = iph->daddr;
 	fl6.saddr = iph->saddr;
-	fl6.flowlabel = (*(__be32 *) iph) & IPV6_FLOWINFO_MASK;
+	fl6.flowlabel = __get_unaligned_cpu32((__be32 *) iph) & IPV6_FLOWINFO_MASK;
 
 	dst = ip6_route_output(net, NULL, &fl6);
 	if (!dst->error)
diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c
index f8c4c08..8ce1aa6 100644
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@ -166,8 +166,8 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 			     pskb_may_pull(skb, nh + offset + 4 - skb->data))) {
 				__be16 *ports = (__be16 *)exthdr;
 
-				fl6->fl6_sport = ports[!!reverse];
-				fl6->fl6_dport = ports[!reverse];
+				fl6->fl6_sport = __get_unaligned_cpu16(&ports[!!reverse]);
+				fl6->fl6_dport = __get_unaligned_cpu16(&ports[!reverse]);
 			}
 			fl6->flowi6_proto = nexthdr;
 			return;
diff --git a/net/netfilter/nf_conntrack_proto_tcp.c b/net/netfilter/nf_conntrack_proto_tcp.c
index 61f9285..13b4b80 100644
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@ -449,7 +449,7 @@ static void tcp_sack(const struct sk_buff *skb, unsigned int dataoff,
 
 	/* Fast path for timestamp-only option */
 	if (length == TCPOLEN_TSTAMP_ALIGNED
-	    && *(__be32 *)ptr == htonl((TCPOPT_NOP << 24)
+	    && __get_unaligned_cpu32((__be32 *)ptr) == htonl((TCPOPT_NOP << 24)
 				       | (TCPOPT_NOP << 16)
 				       | (TCPOPT_TIMESTAMP << 8)
 				       | TCPOLEN_TIMESTAMP))
diff --git a/net/netfilter/xt_LOG.c b/net/netfilter/xt_LOG.c
index fa40096..44946eb 100644
--- a/net/netfilter/xt_LOG.c
+++ b/net/netfilter/xt_LOG.c
@@ -521,9 +521,9 @@ static void dump_ipv6_packet(struct sbuff *m,
 	/* Max length: 44 "LEN=65535 TC=255 HOPLIMIT=255 FLOWLBL=FFFFF " */
 	sb_add(m, "LEN=%Zu TC=%u HOPLIMIT=%u FLOWLBL=%u ",
 	       ntohs(ih->payload_len) + sizeof(struct ipv6hdr),
-	       (ntohl(*(__be32 *)ih) & 0x0ff00000) >> 20,
+	       (ntohl(__get_unaligned_cpu32((__be32 *)ih)) & 0x0ff00000) >> 20,
 	       ih->hop_limit,
-	       (ntohl(*(__be32 *)ih) & 0x000fffff));
+	       (ntohl(__get_unaligned_cpu32((__be32 *)ih)) & 0x000fffff));
 
 	fragment = 0;
 	ptr = ip6hoff + sizeof(struct ipv6hdr);
diff --git a/net/sched/cls_u32.c b/net/sched/cls_u32.c
index c7c27bc..9d4d5c9 100644
--- a/net/sched/cls_u32.c
+++ b/net/sched/cls_u32.c
@@ -142,7 +142,7 @@ next_knode:
 			data = skb_header_pointer(skb, toff, 4, &hdata);
 			if (!data)
 				goto out;
-			if ((*data ^ key->val) & key->mask) {
+			if ((__get_unaligned_cpu32(data) ^ key->val) & key->mask) {
 				n = n->next;
 				goto next_knode;
 			}
@@ -193,7 +193,7 @@ check_terminal:
 						  &hdata);
 			if (!data)
 				goto out;
-			sel = ht->divisor & u32_hash_fold(*data, &n->sel,
+			sel = ht->divisor & u32_hash_fold(__get_unaligned_cpu32(data), &n->sel,
 							  n->fshift);
 		}
 		if (!(n->sel.flags & (TC_U32_VAROFFSET | TC_U32_OFFSET | TC_U32_EAT)))
@@ -209,7 +209,7 @@ check_terminal:
 							  2, &hdata);
 				if (!data)
 					goto out;
-				off2 += ntohs(n->sel.offmask & *data) >>
+				off2 += ntohs(n->sel.offmask & __get_unaligned_cpu16(data)) >>
 					n->sel.offshift;
 			}
 			off2 &= ~3;
diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c
index a18d975..7ccb37f 100644
--- a/net/sched/sch_api.c
+++ b/net/sched/sch_api.c
@@ -1658,7 +1658,7 @@ done:
 int tc_classify_compat(struct sk_buff *skb, const struct tcf_proto *tp,
 		       struct tcf_result *res)
 {
-	__be16 protocol = skb->protocol;
+	__be16 protocol = __get_unaligned_cpu16(&skb->protocol);
 	int err;
 
 	for (; tp; tp = tp->next) {
diff --git a/net/xfrm/xfrm_input.c b/net/xfrm/xfrm_input.c
index ab2bb42..e32ad98 100644
--- a/net/xfrm/xfrm_input.c
+++ b/net/xfrm/xfrm_input.c
@@ -52,6 +52,7 @@ int xfrm_parse_spi(struct sk_buff *skb, u8 nexthdr, __be32 *spi, __be32 *seq)
 {
 	int offset, offset_seq;
 	int hlen;
+	__be32 *pspi, *pseq;
 
 	switch (nexthdr) {
 	case IPPROTO_AH:
@@ -77,8 +78,10 @@ int xfrm_parse_spi(struct sk_buff *skb, u8 nexthdr, __be32 *spi, __be32 *seq)
 	if (!pskb_may_pull(skb, hlen))
 		return -EINVAL;
 
-	*spi = *(__be32*)(skb_transport_header(skb) + offset);
-	*seq = *(__be32*)(skb_transport_header(skb) + offset_seq);
+	pspi = (__be32*)(skb_transport_header(skb) + offset);
+	pseq = (__be32*)(skb_transport_header(skb) + offset_seq);
+	*spi = __get_unaligned_cpu32(pspi);
+	*seq = __get_unaligned_cpu32(pseq);
 	return 0;
 }
 
