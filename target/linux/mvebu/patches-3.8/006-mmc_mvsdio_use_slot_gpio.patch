The MMC core subsystem provides in drivers/mmc/core/slot-gpio.c a nice
set of helper functions to simplify the management of the write
protect GPIO in MMC host drivers. This patch migrates the mvsdio
driver to using those helpers, which will make the ->probe() code
simpler, and therefore ease the process of adding a Device Tree
binding for this driver.

Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
---
 drivers/mmc/host/mvsdio.c |   34 +++++-----------------------------
 1 file changed, 5 insertions(+), 29 deletions(-)

--- a/drivers/mmc/host/mvsdio.c
+++ b/drivers/mmc/host/mvsdio.c
@@ -22,6 +22,7 @@
 #include <linux/clk.h>
 #include <linux/gpio.h>
 #include <linux/mmc/host.h>
+#include <linux/mmc/slot-gpio.h>
 
 #include <asm/sizes.h>
 #include <asm/unaligned.h>
@@ -54,7 +55,6 @@ struct mvsd_host {
 	int irq;
 	struct clk *clk;
 	int gpio_card_detect;
-	int gpio_write_protect;
 };
 
 #define mvsd_write(offs, val)	writel(val, iobase + (offs))
@@ -566,20 +566,6 @@ static void mvsd_enable_sdio_irq(struct
 	spin_unlock_irqrestore(&host->lock, flags);
 }
 
-static int mvsd_get_ro(struct mmc_host *mmc)
-{
-	struct mvsd_host *host = mmc_priv(mmc);
-
-	if (host->gpio_write_protect)
-		return gpio_get_value(host->gpio_write_protect);
-
-	/*
-	 * Board doesn't support read only detection; let the mmc core
-	 * decide what to do.
-	 */
-	return -ENOSYS;
-}
-
 static void mvsd_power_up(struct mvsd_host *host)
 {
 	void __iomem *iobase = host->base;
@@ -676,7 +662,7 @@ static void mvsd_set_ios(struct mmc_host
 
 static const struct mmc_host_ops mvsd_ops = {
 	.request		= mvsd_request,
-	.get_ro			= mvsd_get_ro,
+	.get_ro			= mmc_gpio_get_ro,
 	.set_ios		= mvsd_set_ios,
 	.enable_sdio_irq	= mvsd_enable_sdio_irq,
 };
@@ -798,15 +784,7 @@ static int __init mvsd_probe(struct plat
 	if (!host->gpio_card_detect)
 		mmc->caps |= MMC_CAP_NEEDS_POLL;
 
-	if (mvsd_data->gpio_write_protect) {
-		ret = gpio_request(mvsd_data->gpio_write_protect,
-				   DRIVER_NAME " wp");
-		if (ret == 0) {
-			gpio_direction_input(mvsd_data->gpio_write_protect);
-			host->gpio_write_protect =
-				mvsd_data->gpio_write_protect;
-		}
-	}
+	mmc_gpio_request_ro(mmc, mvsd_data->gpio_write_protect);
 
 	setup_timer(&host->timer, mvsd_timeout_timer, (unsigned long)host);
 	platform_set_drvdata(pdev, mmc);
@@ -831,8 +809,7 @@ out:
 			free_irq(gpio_to_irq(host->gpio_card_detect), host);
 			gpio_free(host->gpio_card_detect);
 		}
-		if (host->gpio_write_protect)
-			gpio_free(host->gpio_write_protect);
+		mmc_gpio_free_ro(mmc);
 		if (host->base)
 			iounmap(host->base);
 	}
@@ -861,8 +838,7 @@ static int __exit mvsd_remove(struct pla
 		}
 		mmc_remove_host(mmc);
 		free_irq(host->irq, host);
-		if (host->gpio_write_protect)
-			gpio_free(host->gpio_write_protect);
+		mmc_gpio_free_ro(mmc);
 		del_timer_sync(&host->timer);
 		mvsd_power_down(host);
 		iounmap(host->base);
