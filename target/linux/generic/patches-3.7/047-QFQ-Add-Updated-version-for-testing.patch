From 53b82528996bfbab9048f7e89bbce9892a67f983 Mon Sep 17 00:00:00 2001
From: Dave Taht <dave.taht@bufferbloat.net>
Date: Tue, 1 Jan 2013 09:02:30 -0800
Subject: [PATCH 7/7] QFQ: Add Updated version for testing

Paolo has been working on a better version of QFQ that will
hopefully do better scheduling AND be lighter weight AND
work on mips.
---
 net/sched/sch_qfq.c | 1183 ++++++++++++++++++++++++++++++++++++++-------------
 1 file changed, 899 insertions(+), 284 deletions(-)

diff --git a/net/sched/sch_qfq.c b/net/sched/sch_qfq.c
index 9687fa1..28fb2f5 100644
--- a/net/sched/sch_qfq.c
+++ b/net/sched/sch_qfq.c
@@ -1,7 +1,8 @@
 /*
- * net/sched/sch_qfq.c         Quick Fair Queueing Scheduler.
+ * net/sched/sch_qfq.c         Quick Fair Queueing Plus Scheduler.
  *
  * Copyright (c) 2009 Fabio Checconi, Luigi Rizzo, and Paolo Valente.
+ * Copyright (c) 2012 Paolo Valente.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -19,12 +20,18 @@
 #include <net/pkt_cls.h>
 
 
-/*  Quick Fair Queueing
-    ===================
+/*  Quick Fair Queueing Plus
+    ========================
 
     Sources:
 
-    Fabio Checconi, Luigi Rizzo, and Paolo Valente: "QFQ: Efficient
+    [1] Paolo Valente,
+    "Reducing the Execution Time of Fair-Queueing Schedulers."
+    http://algo.ing.unimo.it/people/paolo/agg-sched/agg-sched.pdf
+
+    Sources for QFQ:
+
+    [2] Fabio Checconi, Luigi Rizzo, and Paolo Valente: "QFQ: Efficient
     Packet Scheduling with Tight Bandwidth Distribution Guarantees."
 
     See also:
@@ -33,6 +40,20 @@
 
 /*
 
+  QFQ+ divides classes into aggregates of at most MAX_AGG_CLASSES
+  classes. Each aggregate is timestamped with a virtual start time S
+  and a virtual finish time F, and scheduled according to its
+  timestamps. S and F are computed as a function of a system virtual
+  time function V. The classes within each aggregate are instead
+  scheduled with DRR.
+
+  To speed up operations, QFQ+ divides also aggregates into a limited
+  number of groups. Which group a class belongs to depends on the
+  ratio between the maximum packet length for the class and the weight
+  of the class. Groups have their own S and F. In the end, QFQ+
+  schedules groups, then aggregates within groups, then classes within
+  aggregates. See [1] and [2] for a full description.
+
   Virtual time computations.
 
   S, F and V are all computed in fixed point arithmetic with
@@ -76,27 +97,30 @@
 #define QFQ_MAX_SLOTS	32
 
 /*
- * Shifts used for class<->group mapping.  We allow class weights that are
- * in the range [1, 2^MAX_WSHIFT], and we try to map each class i to the
+ * Shifts used for aggregate<->group mapping.  We allow class weights that are
+ * in the range [1, 2^MAX_WSHIFT], and we try to map each aggregate i to the
  * group with the smallest index that can support the L_i / r_i configured
- * for the class.
+ * for the classes in the aggregate.
  *
  * grp->index is the index of the group; and grp->slot_shift
  * is the shift for the corresponding (scaled) sigma_i.
  */
 #define QFQ_MAX_INDEX		24
-#define QFQ_MAX_WSHIFT		12
+#define QFQ_MAX_WSHIFT		10
 
-#define	QFQ_MAX_WEIGHT		(1<<QFQ_MAX_WSHIFT)
-#define QFQ_MAX_WSUM		(16*QFQ_MAX_WEIGHT)
+#define	QFQ_MAX_WEIGHT		(1<<QFQ_MAX_WSHIFT) /* see qfq_slot_insert */
+#define QFQ_MAX_WSUM		(64*QFQ_MAX_WEIGHT)
 
 #define FRAC_BITS		30	/* fixed point arithmetic */
 #define ONE_FP			(1UL << FRAC_BITS)
 #define IWSUM			(ONE_FP/QFQ_MAX_WSUM)
 
 #define QFQ_MTU_SHIFT		16	/* to support TSO/GSO */
-#define QFQ_MIN_SLOT_SHIFT	(FRAC_BITS + QFQ_MTU_SHIFT - QFQ_MAX_INDEX)
-#define QFQ_MIN_LMAX		256	/* min possible lmax for a class */
+#define QFQ_MIN_LMAX		512	/* see qfq_slot_insert */
+
+#define QFQ_MAX_AGG_CLASSES	8 /* max num classes per aggregate allowed */
+
+unsigned long qlen;
 
 /*
  * Possible group states.  These values are used as indexes for the bitmaps
@@ -106,6 +130,8 @@ enum qfq_state { ER, IR, EB, IB, QFQ_MAX_STATE };
 
 struct qfq_group;
 
+struct qfq_aggregate;
+
 struct qfq_class {
 	struct Qdisc_class_common common;
 
@@ -116,7 +142,12 @@ struct qfq_class {
 	struct gnet_stats_queue qstats;
 	struct gnet_stats_rate_est rate_est;
 	struct Qdisc *qdisc;
+	struct list_head alist;		/* Link for active-classes list. */
+	struct qfq_aggregate *agg;	/* Parent aggregate. */
+	int deficit;			/* DRR deficit counter. */
+};
 
+struct qfq_aggregate {
 	struct hlist_node next;	/* Link for the slot list. */
 	u64 S, F;		/* flow timestamps (exact) */
 
@@ -127,8 +158,18 @@ struct qfq_class {
 	struct qfq_group *grp;
 
 	/* these are copied from the flowset. */
-	u32	inv_w;		/* ONE_FP/weight */
-	u32	lmax;		/* Max packet size for this flow. */
+	u32	class_weight; /* Weight of each class in this aggregate. */
+	/* Max pkt size for the classes in this aggregate, DRR quantum. */
+	int	lmax;
+
+	u32	inv_w;	    /* ONE_FP/(sum of weights of classes in aggr.). */
+	u32	budgetmax;  /* Max budget for this aggregate. */
+	u32	initial_budget, budget;     /* Initial and current budget. */
+
+	int		  num_classes;	/* Number of classes in this aggr. */
+	struct list_head  active;	/* DRR queue of active classes. */
+
+	struct hlist_node nonfull_next;	/* See nonfull_aggs in qfq_sched. */
 };
 
 struct qfq_group {
@@ -138,7 +179,7 @@ struct qfq_group {
 	unsigned int front;		/* Index of the front slot. */
 	unsigned long full_slots;	/* non-empty slots */
 
-	/* Array of RR lists of active classes. */
+	/* Array of RR lists of active aggregates. */
 	struct hlist_head slots[QFQ_MAX_SLOTS];
 };
 
@@ -146,13 +187,28 @@ struct qfq_sched {
 	struct tcf_proto *filter_list;
 	struct Qdisc_class_hash clhash;
 
-	u64		V;		/* Precise virtual time. */
-	u32		wsum;		/* weight sum */
+	u64			oldV, V;	/* Precise virtual times. */
+	struct qfq_aggregate	*in_serv_agg;   /* Aggregate being served. */
+	u32			num_active_agg; /* Num. of active aggregates */
+	u32			wsum;		/* weight sum */
 
 	unsigned long bitmaps[QFQ_MAX_STATE];	    /* Group bitmaps. */
 	struct qfq_group groups[QFQ_MAX_INDEX + 1]; /* The groups. */
+	u32 min_slot_shift;	/* Index of the group-0 bit in the bitmaps. */
+
+	u32 max_agg_classes;		/* Max number of classes per aggr. */
+	struct hlist_head nonfull_aggs; /* Aggs with room for more classes. */
 };
 
+/*
+ * Possible reasons why the timestamps of an aggregate are updated
+ * enqueue: the aggregate switches from idle to active and must scheduled
+ *	    for service
+ * requeue: the aggregate finishes its budget, so it stops being served and
+ *	    must be rescheduled for service
+ */
+enum update_reason {enqueue, requeue};
+
 static struct qfq_class *qfq_find_class(struct Qdisc *sch, u32 classid)
 {
 	struct qfq_sched *q = qdisc_priv(sch);
@@ -182,88 +238,198 @@ static const struct nla_policy qfq_policy[TCA_QFQ_MAX + 1] = {
  * index = log_2(maxlen/weight) but we need to apply the scaling.
  * This is used only once at flow creation.
  */
-static int qfq_calc_index(u32 inv_w, unsigned int maxlen)
+static int qfq_calc_index(u32 inv_w, unsigned int maxlen, u32 min_slot_shift)
 {
 	u64 slot_size = (u64)maxlen * inv_w;
 	unsigned long size_map;
 	int index = 0;
 
-	size_map = slot_size >> QFQ_MIN_SLOT_SHIFT;
+	size_map = slot_size >> min_slot_shift;
 	if (!size_map)
 		goto out;
 
 	index = __fls(size_map) + 1;	/* basically a log_2 */
-	index -= !(slot_size - (1ULL << (index + QFQ_MIN_SLOT_SHIFT - 1)));
+	index -= !(slot_size - (1ULL << (index + min_slot_shift - 1)));
 
 	if (index < 0)
 		index = 0;
 out:
 	pr_debug("qfq calc_index: W = %lu, L = %u, I = %d\n",
 		 (unsigned long) ONE_FP/inv_w, maxlen, index);
+	BUG_ON(index > QFQ_MAX_INDEX);
 
 	return index;
 }
 
-/* Length of the next packet (0 if the queue is empty). */
-static unsigned int qdisc_peek_len(struct Qdisc *sch)
+static void qfq_deactivate_agg(struct qfq_sched *, struct qfq_aggregate *);
+static void qfq_activate_agg(struct qfq_sched *, struct qfq_aggregate *,
+			     enum update_reason);
+
+static void qfq_init_agg(struct qfq_sched *q, struct qfq_aggregate *agg,
+			 u32 lmax, u32 weight)
 {
-	struct sk_buff *skb;
+	INIT_LIST_HEAD(&agg->active);
+	hlist_add_head(&agg->nonfull_next, &q->nonfull_aggs);
+
+	agg->lmax = lmax;
+	agg->class_weight = weight;
+}
 
-	skb = sch->ops->peek(sch);
-	return skb ? qdisc_pkt_len(skb) : 0;
+static struct qfq_aggregate *qfq_find_agg(struct qfq_sched *q,
+					  u32 lmax, u32 weight)
+{
+	struct qfq_aggregate *agg;
+	struct hlist_node *n;
+
+	hlist_for_each_entry(agg, n, &q->nonfull_aggs, nonfull_next)
+		if (agg->lmax == lmax && agg->class_weight == weight)
+			return agg;
+
+	return NULL;
 }
 
-static void qfq_deactivate_class(struct qfq_sched *, struct qfq_class *);
-static void qfq_activate_class(struct qfq_sched *q, struct qfq_class *cl,
-			       unsigned int len);
 
-static void qfq_update_class_params(struct qfq_sched *q, struct qfq_class *cl,
-				    u32 lmax, u32 inv_w, int delta_w)
+/* Update aggregate as a function of the new number of classes. */
+static void qfq_update_agg(struct qfq_sched *q, struct qfq_aggregate *agg,
+			   int new_num_classes)
 {
-	int i;
+	u32 new_agg_weight;
+
+	if (new_num_classes == q->max_agg_classes)
+		hlist_del_init(&agg->nonfull_next);
+
+	if (agg->num_classes > new_num_classes &&
+	    new_num_classes == q->max_agg_classes - 1) /* agg no more full */
+		hlist_add_head(&agg->nonfull_next, &q->nonfull_aggs);
 
-	/* update qfq-specific data */
-	cl->lmax = lmax;
-	cl->inv_w = inv_w;
-	i = qfq_calc_index(cl->inv_w, cl->lmax);
+	/* 
+	 * the next assignment may let
+	 * agg->initial_budget > agg->budgetmax
+	 * hold, but this does not cause any harm
+	 */
+	agg->budgetmax = new_num_classes * agg->lmax;
+	new_agg_weight = agg->class_weight * new_num_classes;
+	agg->inv_w = ONE_FP/new_agg_weight;
+
+	if (agg->grp == NULL) {
+		int i = qfq_calc_index(agg->inv_w, agg->budgetmax,
+				       q->min_slot_shift);
+		BUG_ON(!list_empty(&agg->active));
+		agg->grp = &q->groups[i];
+	}
 
-	cl->grp = &q->groups[i];
+	q->wsum +=
+		(int) agg->class_weight * (new_num_classes - agg->num_classes);
 
-	q->wsum += delta_w;
+	agg->num_classes = new_num_classes;
 }
 
-static void qfq_update_reactivate_class(struct qfq_sched *q,
-					struct qfq_class *cl,
-					u32 inv_w, u32 lmax, int delta_w)
+static inline int qfq_gt(u64 a, u64 b);
+
+/* Add class to aggregate. */
+static void qfq_add_to_agg(struct qfq_sched *q,
+			   struct qfq_aggregate *agg,
+			   struct qfq_class *cl)
 {
-	bool need_reactivation = false;
-	int i = qfq_calc_index(inv_w, lmax);
+	BUG_ON(agg == NULL);
+	BUG_ON(cl->agg != NULL);
+	BUG_ON(agg->num_classes >= q->max_agg_classes);
 
-	if (&q->groups[i] != cl->grp && cl->qdisc->q.qlen > 0) {
-		/*
-		 * shift cl->F back, to not charge the
-		 * class for the not-yet-served head
-		 * packet
-		 */
-		cl->F = cl->S;
-		/* remove class from its slot in the old group */
-		qfq_deactivate_class(q, cl);
-		need_reactivation = true;
+	cl->agg = agg;
+
+	qfq_update_agg(q, agg, agg->num_classes+1);
+	if (cl->qdisc->q.qlen > 0) { /* adding an active class */
+		list_add_tail(&cl->alist, &agg->active);
+		if (list_first_entry(&agg->active, struct qfq_class, alist) !=
+		    cl || q->in_serv_agg == agg)
+			return;
+		BUG_ON(qfq_gt(agg->S, q->V +
+			      (2ULL << agg->grp->slot_shift)));
+
+		qfq_activate_agg(q, agg, enqueue);
 	}
+}
 
-	qfq_update_class_params(q, cl, lmax, inv_w, delta_w);
+static struct qfq_aggregate *qfq_choose_next_agg(struct qfq_sched *);
 
-	if (need_reactivation) /* activate in new group */
-		qfq_activate_class(q, cl, qdisc_peek_len(cl->qdisc));
+static void qfq_destroy_agg(struct qfq_sched *q, struct qfq_aggregate *agg)
+{
+	if (!hlist_unhashed(&agg->nonfull_next))
+		hlist_del_init(&agg->nonfull_next);
+	if (q->in_serv_agg == agg)
+		q->in_serv_agg = qfq_choose_next_agg(q);
+	kfree(agg);
 }
 
+/* Deschedule class from within its parent aggregate. */
+static void qfq_deactivate_class(struct qfq_sched *q, struct qfq_class *cl)
+{
+
+	struct qfq_aggregate *agg;
+
+	BUG_ON(!cl);
+	agg = cl->agg;
+
+	BUG_ON(!cl->agg);
+
+	list_del(&cl->alist); /* remove from RR queue of the aggregate */
+	if (list_empty(&agg->active)) /* agg is now inactive */
+		qfq_deactivate_agg(q, agg);
+}
+
+/* Remove class from its parent aggregate. */
+static void qfq_rm_from_agg(struct qfq_sched *q, struct qfq_class *cl)
+{
+	struct qfq_aggregate *agg = cl->agg;
+
+	cl->agg = NULL;
+	if (agg->num_classes == 1) { /* agg being emptied, destroy it */
+		qfq_destroy_agg(q, agg);
+		return;
+	}
+	qfq_update_agg(q, agg, agg->num_classes-1);
+}
+
+/* Deschedule class and remove it from its parent aggregate. */
+static void qfq_deact_rm_from_agg(struct qfq_sched *q, struct qfq_class *cl)
+{
+	if (cl->qdisc->q.qlen > 0) /* class is active */
+		qfq_deactivate_class(q, cl);
+
+	qfq_rm_from_agg(q, cl);
+}
+
+/* Move class to a new aggregate, matching the new class weight and/or lmax */
+static int qfq_change_agg(struct Qdisc *sch, struct qfq_class *cl, u32 weight,
+			   u32 lmax)
+{
+	struct qfq_sched *q = qdisc_priv(sch);
+	struct qfq_aggregate *new_agg = qfq_find_agg(q, lmax, weight);
+
+	if (new_agg == NULL) { /* create new aggregate */
+		new_agg = kzalloc(sizeof(*new_agg), GFP_ATOMIC);
+		if (new_agg == NULL)
+			return -ENOBUFS;
+		qfq_init_agg(q, new_agg, lmax, weight);
+	}
+	BUG_ON((q->bitmaps[ER] | q->bitmaps[IR] | q->bitmaps[IB]) == 0 &&
+	       qlen > 0 && q->in_serv_agg == NULL);
+	qfq_deact_rm_from_agg(q, cl);
+	qfq_add_to_agg(q, new_agg, cl);
+	BUG_ON((q->bitmaps[ER] | q->bitmaps[IR] | q->bitmaps[IB]) == 0 &&
+	       qlen > 0 && q->in_serv_agg == NULL);
+
+	return 0;
+}
 
 static int qfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 			    struct nlattr **tca, unsigned long *arg)
 {
 	struct qfq_sched *q = qdisc_priv(sch);
 	struct qfq_class *cl = (struct qfq_class *)*arg;
+	bool existing = false;
 	struct nlattr *tb[TCA_QFQ_MAX + 1];
+	struct qfq_aggregate *new_agg = NULL;
 	u32 weight, lmax, inv_w;
 	int err;
 	int delta_w;
@@ -286,15 +452,6 @@ static int qfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 	} else
 		weight = 1;
 
-	inv_w = ONE_FP / weight;
-	weight = ONE_FP / inv_w;
-	delta_w = weight - (cl ? ONE_FP / cl->inv_w : 0);
-	if (q->wsum + delta_w > QFQ_MAX_WSUM) {
-		pr_notice("qfq: total weight out of range (%u + %u)\n",
-			  delta_w, q->wsum);
-		return -EINVAL;
-	}
-
 	if (tb[TCA_QFQ_LMAX]) {
 		lmax = nla_get_u32(tb[TCA_QFQ_LMAX]);
 		if (lmax < QFQ_MIN_LMAX || lmax > (1UL << QFQ_MTU_SHIFT)) {
@@ -304,7 +461,23 @@ static int qfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 	} else
 		lmax = psched_mtu(qdisc_dev(sch));
 
-	if (cl != NULL) {
+	inv_w = ONE_FP / weight;
+	weight = ONE_FP / inv_w;
+
+	if (cl != NULL &&
+	    lmax == cl->agg->lmax &&
+	    weight == cl->agg->class_weight)
+		return 0; /* nothing to change */
+
+	delta_w = weight - (cl ? cl->agg->class_weight : 0);
+
+	if (q->wsum + delta_w > QFQ_MAX_WSUM) {
+		pr_notice("qfq: total weight out of range (%d + %u)\n",
+			  delta_w, q->wsum);
+		return -EINVAL;
+	}
+
+	if (cl != NULL) { /* modify existing class */
 		if (tca[TCA_RATE]) {
 			err = gen_replace_estimator(&cl->bstats, &cl->rate_est,
 						    qdisc_root_sleeping_lock(sch),
@@ -312,25 +485,18 @@ static int qfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 			if (err)
 				return err;
 		}
-
-		if (lmax == cl->lmax && inv_w == cl->inv_w)
-			return 0; /* nothing to update */
-
-		sch_tree_lock(sch);
-		qfq_update_reactivate_class(q, cl, inv_w, lmax, delta_w);
-		sch_tree_unlock(sch);
-
-		return 0;
+		existing = true;
+		goto set_change_agg;
 	}
 
+	/* create and init new class */
 	cl = kzalloc(sizeof(struct qfq_class), GFP_KERNEL);
 	if (cl == NULL)
 		return -ENOBUFS;
 
 	cl->refcnt = 1;
 	cl->common.classid = classid;
-
-	qfq_update_class_params(q, cl, lmax, inv_w, delta_w);
+	cl->deficit = lmax;
 
 	cl->qdisc = qdisc_create_dflt(sch->dev_queue,
 				      &pfifo_qdisc_ops, classid);
@@ -341,11 +507,8 @@ static int qfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 		err = gen_new_estimator(&cl->bstats, &cl->rate_est,
 					qdisc_root_sleeping_lock(sch),
 					tca[TCA_RATE]);
-		if (err) {
-			qdisc_destroy(cl->qdisc);
-			kfree(cl);
-			return err;
-		}
+		if (err)
+			goto destroy_class;
 	}
 
 	sch_tree_lock(sch);
@@ -354,19 +517,45 @@ static int qfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 
 	qdisc_class_hash_grow(sch, &q->clhash);
 
+set_change_agg:
+	sch_tree_lock(sch);
+	new_agg = qfq_find_agg(q, lmax, weight);
+	if (new_agg == NULL) { /* create new aggregate */
+		sch_tree_unlock(sch);
+		new_agg = kzalloc(sizeof(*new_agg), GFP_KERNEL);
+		if (new_agg == NULL) {
+			err = -ENOBUFS;
+			gen_kill_estimator(&cl->bstats, &cl->rate_est);
+			goto destroy_class;
+		}
+		sch_tree_lock(sch);
+		qfq_init_agg(q, new_agg, lmax, weight);
+	}
+	BUG_ON((q->bitmaps[ER] | q->bitmaps[IR] | q->bitmaps[IB]) == 0 &&
+	       qlen > 0 && q->in_serv_agg == NULL);
+
+	if (existing)
+		qfq_deact_rm_from_agg(q, cl);
+
+	qfq_add_to_agg(q, new_agg, cl);
+	BUG_ON((q->bitmaps[ER] | q->bitmaps[IR] | q->bitmaps[IB]) == 0 &&
+	       qlen > 0 && q->in_serv_agg == NULL);
+	sch_tree_unlock(sch);
+
 	*arg = (unsigned long)cl;
 	return 0;
+
+destroy_class:
+	qdisc_destroy(cl->qdisc);
+	kfree(cl);
+	return err;
 }
 
 static void qfq_destroy_class(struct Qdisc *sch, struct qfq_class *cl)
 {
 	struct qfq_sched *q = qdisc_priv(sch);
 
-	if (cl->inv_w) {
-		q->wsum -= ONE_FP / cl->inv_w;
-		cl->inv_w = 0;
-	}
-
+	qfq_rm_from_agg(q, cl);
 	gen_kill_estimator(&cl->bstats, &cl->rate_est);
 	qdisc_destroy(cl->qdisc);
 	kfree(cl);
@@ -481,8 +670,8 @@ static int qfq_dump_class(struct Qdisc *sch, unsigned long arg,
 	nest = nla_nest_start(skb, TCA_OPTIONS);
 	if (nest == NULL)
 		goto nla_put_failure;
-	if (nla_put_u32(skb, TCA_QFQ_WEIGHT, ONE_FP/cl->inv_w) ||
-	    nla_put_u32(skb, TCA_QFQ_LMAX, cl->lmax))
+	if (nla_put_u32(skb, TCA_QFQ_WEIGHT, cl->agg->class_weight) ||
+	    nla_put_u32(skb, TCA_QFQ_LMAX, cl->agg->lmax))
 		goto nla_put_failure;
 	return nla_nest_end(skb, nest);
 
@@ -500,8 +689,8 @@ static int qfq_dump_class_stats(struct Qdisc *sch, unsigned long arg,
 	memset(&xstats, 0, sizeof(xstats));
 	cl->qdisc->qstats.qlen = cl->qdisc->q.qlen;
 
-	xstats.weight = ONE_FP/cl->inv_w;
-	xstats.lmax = cl->lmax;
+	xstats.weight = cl->agg->class_weight;
+	xstats.lmax = cl->agg->lmax;
 
 	if (gnet_stats_copy_basic(d, &cl->bstats) < 0 ||
 	    gnet_stats_copy_rate_est(d, &cl->bstats, &cl->rate_est) < 0 ||
@@ -581,6 +770,7 @@ static inline int qfq_gt(u64 a, u64 b)
 /* Round a precise timestamp to its slotted value. */
 static inline u64 qfq_round_down(u64 ts, unsigned int shift)
 {
+	BUG_ON(shift > 63);
 	return ts & ~((1ULL << shift) - 1);
 }
 
@@ -608,7 +798,7 @@ static int qfq_calc_state(struct qfq_sched *q, const struct qfq_group *grp)
 	unsigned int state = qfq_gt(grp->S, q->V);
 	unsigned long mask = mask_from(q->bitmaps[ER], grp->index);
 	struct qfq_group *next;
-
+	BUG_ON(qfq_gt(grp->S, q->V + (2ULL<<grp->slot_shift)));
 	if (mask) {
 		next = qfq_ffs(q, mask);
 		if (qfq_gt(grp->F, next->F))
@@ -652,55 +842,111 @@ static void qfq_unblock_groups(struct qfq_sched *q, int index, u64 old_F)
  * perhaps
  *
 	old_V ^= q->V;
-	old_V >>= QFQ_MIN_SLOT_SHIFT;
+	old_V >>= q->min_slot_shift;
 	if (old_V) {
 		...
 	}
  *
  */
-static void qfq_make_eligible(struct qfq_sched *q, u64 old_V)
+static void qfq_make_eligible(struct qfq_sched *q)
 {
-	unsigned long vslot = q->V >> QFQ_MIN_SLOT_SHIFT;
-	unsigned long old_vslot = old_V >> QFQ_MIN_SLOT_SHIFT;
+	unsigned long vslot = q->V >> q->min_slot_shift;
+	unsigned long old_vslot = q->oldV >> q->min_slot_shift;
+	unsigned long oldIR = q->bitmaps[IR];
+	unsigned long oldIB = q->bitmaps[IB];
+	unsigned long mask_dbg = 0;
+
+	BUG_ON(q->bitmaps[ER] == 0 && (q->bitmaps[EB] | q->bitmaps[IB]) != 0);
+
+	BUG_ON((q->bitmaps[ER] | q->bitmaps[IR] | q->bitmaps[IB]) == 0 &&
+	       qlen > 0);
 
 	if (vslot != old_vslot) {
-		unsigned long mask = (1UL << fls(vslot ^ old_vslot)) - 1;
+		int maxshift = fls(vslot ^ old_vslot);
+		unsigned long mask;
+		int i;
+
+		if (maxshift > 31)
+			mask = ~0UL;
+		else
+			mask = (1UL << maxshift) - 1;
+		
+		for (i = 0; i <= QFQ_MAX_INDEX; i++) {
+			struct qfq_group *grp = &q->groups[i];
+			BUG_ON((test_bit(grp->index, &q->bitmaps[ER]) ||
+				test_bit(grp->index, &q->bitmaps[EB]))
+			       && qfq_gt(grp->S, q->V));
+			BUG_ON((test_bit(grp->index, &q->bitmaps[IR]) ||
+				test_bit(grp->index, &q->bitmaps[IB]))
+			       &&
+			       qfq_gt(grp->S, q->V + (1ULL<<grp->slot_shift)));
+		}
 		qfq_move_groups(q, mask, IR, ER);
 		qfq_move_groups(q, mask, IB, EB);
+		mask_dbg = mask;
+
+	}
+	if(q->bitmaps[ER] == 0 && q->bitmaps[IR] != 0) {
+		struct qfq_group *grp = qfq_ffs(q, q->bitmaps[IR] |
+						q->bitmaps[IB]);
+		printk("qfq_make_eligible oldIR %lx oldIB %lx mask %lx\n",
+		       oldIR, oldIB, mask_dbg);
+		printk("qfq_make_eligible IR %lx IB %lx ER %lx\n",
+		       q->bitmaps[IR], q->bitmaps[IB], q->bitmaps[ER]);
+		printk("qfq_make_eligible grp->index %u grp->S %llu\n",
+		       grp->index, grp->S>>q->min_slot_shift);
+		printk("qfq_make_eligible Vslot %lu oldVslot %lu\n",
+		       vslot, old_vslot);
+		printk("qfq_make_eligible fls %d",
+		       fls(vslot ^ old_vslot));
 	}
+
+
+	BUG_ON(q->bitmaps[ER] == 0 && q->bitmaps[EB] != 0);
+
+	BUG_ON(q->bitmaps[ER] == 0 && q->bitmaps[IR] != 0);
+
+	BUG_ON(q->bitmaps[ER] == 0 &&
+	       (q->bitmaps[IR] | q->bitmaps[EB] | q->bitmaps[IB]) != 0);
+	BUG_ON(q->bitmaps[ER] == 0 && qlen > 0);
+
 }
 
 
 /*
- * If the weight and lmax (max_pkt_size) of the classes do not change,
- * then QFQ guarantees that the slot index is never higher than
- * 2 + ((1<<QFQ_MTU_SHIFT)/QFQ_MIN_LMAX) * (QFQ_MAX_WEIGHT/QFQ_MAX_WSUM).
+ * The index of the slot in which the aggregate is to be inserted must
+ * not be higher than QFQ_MAX_SLOTS-2. There is a '-2' and not a '-1'
+ * because the start time of the group may be moved backward by one
+ * slot after the aggregate has been inserted, and this would cause
+ * non-empty slots to be right-shifted by one position.
  *
- * With the current values of the above constants, the index is
- * then guaranteed to never be higher than 2 + 256 * (1 / 16) = 18.
+ * If the weight and lmax (max_pkt_size) of the classes do not change,
+ * then QFQ+ does meet the above contraint according to the current
+ * values of its parameters. In fact, if the weight and lmax of the
+ * classes do not change, then, from the theory, QFQ+ guarantees that
+ * the slot index is never higher than
+ * 2 + QFQ_MAX_AGG_CLASSES * ((1<<QFQ_MTU_SHIFT)/QFQ_MIN_LMAX) *
+ * (QFQ_MAX_WEIGHT/QFQ_MAX_WSUM) = 2 + 8 * 128 * (1 / 64) = 18
  *
  * When the weight of a class is increased or the lmax of the class is
- * decreased, a new class with smaller slot size may happen to be
- * activated. The activation of this class should be properly delayed
- * to when the service of the class has finished in the ideal system
- * tracked by QFQ. If the activation of the class is not delayed to
- * this reference time instant, then this class may be unjustly served
- * before other classes waiting for service. This may cause
- * (unfrequently) the above bound to the slot index to be violated for
- * some of these unlucky classes.
+ * decreased, a new aggregate with smaller slot size than the original
+ * parent aggregate of the class may happen to be activated. The
+ * activation of this aggregate should be properly delayed to when the
+ * service of the class has finished in the ideal system tracked by
+ * QFQ+. If the activation of the aggregate is not delayed to this
+ * reference time instant, then this aggregate may be unjustly served
+ * before other aggregates waiting for service. This may cause the
+ * above bound to the slot index to be violated for some of these
+ * unlucky aggregates.
  *
- * Instead of delaying the activation of the new class, which is quite
- * complex, the following inaccurate but simple solution is used: if
- * the slot index is higher than QFQ_MAX_SLOTS-2, then the timestamps
- * of the class are shifted backward so as to let the slot index
- * become equal to QFQ_MAX_SLOTS-2. This threshold is used because, if
- * the slot index is above it, then the data structure implementing
- * the bucket list either gets immediately corrupted or may get
- * corrupted on a possible next packet arrival that causes the start
- * time of the group to be shifted backward.
+ * Instead of delaying the activation of the new aggregate, which is
+ * quite complex, the following inaccurate but simple solution is used:
+ * if the slot index is higher than QFQ_MAX_SLOTS-2, then the
+ * timestamps of the aggregate are shifted backward so as to let the
+ * slot index become equal to QFQ_MAX_SLOTS-2.
  */
-static void qfq_slot_insert(struct qfq_group *grp, struct qfq_class *cl,
-			    u64 roundedS)
+static void qfq_slot_insert(struct qfq_group *grp, struct qfq_aggregate *agg,
+			    u64 roundedS, struct qfq_sched *q)
 {
 	u64 slot = (roundedS - grp->S) >> grp->slot_shift;
 	unsigned int i; /* slot index in the bucket list */
@@ -708,22 +954,29 @@ static void qfq_slot_insert(struct qfq_group *grp, struct qfq_class *cl,
 	if (unlikely(slot > QFQ_MAX_SLOTS - 2)) {
 		u64 deltaS = roundedS - grp->S -
 			((u64)(QFQ_MAX_SLOTS - 2)<<grp->slot_shift);
-		cl->S -= deltaS;
-		cl->F -= deltaS;
+		agg->S -= deltaS;
+		BUG_ON(qfq_gt(agg->S,
+			      q->V + (2ULL << agg->grp->slot_shift)));
+
+		agg->F -= deltaS;
 		slot = QFQ_MAX_SLOTS - 2;
+		BUG_ON(slot !=
+		       (qfq_round_down(agg->S, grp->slot_shift) - grp->S)>>
+		       grp->slot_shift);
 	}
 
 	i = (grp->front + slot) % QFQ_MAX_SLOTS;
 
-	hlist_add_head(&cl->next, &grp->slots[i]);
+	hlist_add_head(&agg->next, &grp->slots[i]);
 	__set_bit(slot, &grp->full_slots);
 }
 
 /* Maybe introduce hlist_first_entry?? */
-static struct qfq_class *qfq_slot_head(struct qfq_group *grp)
+static struct qfq_aggregate *qfq_slot_head(struct qfq_group *grp)
 {
+	BUG_ON(hlist_empty(&grp->slots[grp->front]));
 	return hlist_entry(grp->slots[grp->front].first,
-			   struct qfq_class, next);
+			   struct qfq_aggregate, next);
 }
 
 /*
@@ -731,20 +984,21 @@ static struct qfq_class *qfq_slot_head(struct qfq_group *grp)
  */
 static void qfq_front_slot_remove(struct qfq_group *grp)
 {
-	struct qfq_class *cl = qfq_slot_head(grp);
+	struct qfq_aggregate *agg = qfq_slot_head(grp);
 
-	BUG_ON(!cl);
-	hlist_del(&cl->next);
+	BUG_ON(!agg);
+	hlist_del(&agg->next);
 	if (hlist_empty(&grp->slots[grp->front]))
 		__clear_bit(0, &grp->full_slots);
+
 }
 
 /*
- * Returns the first full queue in a group. As a side effect,
- * adjust the bucket list so the first non-empty bucket is at
- * position 0 in full_slots.
+ * Returns the first aggregate in the first non-empty bucket of the
+ * group. As a side effect, adjusts the bucket list so the first
+ * non-empty bucket is at position 0 in full_slots.
  */
-static struct qfq_class *qfq_slot_scan(struct qfq_group *grp)
+static struct qfq_aggregate *qfq_slot_scan(struct qfq_group *grp)
 {
 	unsigned int i;
 
@@ -760,6 +1014,7 @@ static struct qfq_class *qfq_slot_scan(struct qfq_group *grp)
 		grp->full_slots >>= i;
 	}
 
+
 	return qfq_slot_head(grp);
 }
 
@@ -772,15 +1027,28 @@ static struct qfq_class *qfq_slot_scan(struct qfq_group *grp)
  * increases of the start time ?
  * Here too we should make sure that i is less than 32
  */
-static void qfq_slot_rotate(struct qfq_group *grp, u64 roundedS)
+static void qfq_slot_rotate(struct qfq_group *grp, u64 roundedS,
+			    struct qfq_sched *q)
 {
 	unsigned int i = (grp->S - roundedS) >> grp->slot_shift;
 
+	if (grp->full_slots == 0)
+		printk("qfq_slot_rotate BUG 1 i %u", i);
+
+	if (QFQ_MAX_SLOTS - __fls(grp->full_slots) <= i)
+		printk("qfq_slot_rotate BUG 2 fls %lu i %u deltaV %c%llu",
+		       __fls(grp->full_slots), i,
+		       qfq_gt(grp->S, q->V) ? '+' : '-',
+		       (qfq_gt(grp->S, q->V) ?
+			(grp->S - q->V) : (q->V - grp->S)) >> grp->slot_shift);
+
+	BUG_ON(QFQ_MAX_SLOTS - __fls(grp->full_slots) <= i);
+
 	grp->full_slots <<= i;
 	grp->front = (grp->front - i) % QFQ_MAX_SLOTS;
 }
 
-static void qfq_update_eligible(struct qfq_sched *q, u64 old_V)
+static void qfq_update_eligible(struct qfq_sched *q)
 {
 	struct qfq_group *grp;
 	unsigned long ineligible;
@@ -788,143 +1056,361 @@ static void qfq_update_eligible(struct qfq_sched *q, u64 old_V)
 	ineligible = q->bitmaps[IR] | q->bitmaps[IB];
 	if (ineligible) {
 		if (!q->bitmaps[ER]) {
+			u64 preV = q->V;
 			grp = qfq_ffs(q, ineligible);
+			BUG_ON(qfq_gt(grp->S, q->V + (1ULL<<grp->slot_shift)));
+			BUG_ON(q->V != q->oldV &&
+			       fls((q->V>>q->min_slot_shift) ^
+				   (q->oldV>>q->min_slot_shift)) >
+			       QFQ_MAX_INDEX);
+
 			if (qfq_gt(grp->S, q->V))
 				q->V = grp->S;
 		}
-		qfq_make_eligible(q, old_V);
+		qfq_make_eligible(q);
 	}
 }
 
-/*
- * Updates the class, returns true if also the group needs to be updated.
- */
-static bool qfq_update_class(struct qfq_group *grp, struct qfq_class *cl)
+/* Dequeue head packet of the head class in the DRR queue of the aggregate. */
+static void agg_dequeue(struct qfq_aggregate *agg,
+			struct qfq_class *cl, unsigned int len)
 {
-	unsigned int len = qdisc_peek_len(cl->qdisc);
-
-	cl->S = cl->F;
-	if (!len)
-		qfq_front_slot_remove(grp);	/* queue is empty */
-	else {
-		u64 roundedS;
+	qdisc_dequeue_peeked(cl->qdisc);
 
-		cl->F = cl->S + (u64)len * cl->inv_w;
-		roundedS = qfq_round_down(cl->S, grp->slot_shift);
-		if (roundedS == grp->S)
-			return false;
+	cl->deficit -= (int) len;
 
-		qfq_front_slot_remove(grp);
-		qfq_slot_insert(grp, cl, roundedS);
+	if (cl->qdisc->q.qlen == 0) /* no more packets, remove from list */
+		list_del(&cl->alist);
+	else if (cl->deficit < qdisc_pkt_len(cl->qdisc->ops->peek(cl->qdisc))) {
+		cl->deficit += agg->lmax;
+		list_move_tail(&cl->alist, &agg->active);
 	}
-
-	return true;
 }
 
-static struct sk_buff *qfq_dequeue(struct Qdisc *sch)
+static inline struct sk_buff *qfq_peek_skb(struct qfq_aggregate *agg,
+					   struct qfq_class **cl,
+					   unsigned int *len)
 {
-	struct qfq_sched *q = qdisc_priv(sch);
-	struct qfq_group *grp;
-	struct qfq_class *cl;
 	struct sk_buff *skb;
-	unsigned int len;
-	u64 old_V;
 
-	if (!q->bitmaps[ER])
-		return NULL;
+	*cl = list_first_entry(&agg->active, struct qfq_class, alist);
+	skb = (*cl)->qdisc->ops->peek((*cl)->qdisc);
+	if (skb == NULL)
+		WARN_ONCE(1, "qfq_dequeue: non-workconserving leaf\n");
+	else
+		*len = qdisc_pkt_len(skb);
 
-	grp = qfq_ffs(q, q->bitmaps[ER]);
+	return skb;
+}
 
-	cl = qfq_slot_head(grp);
-	skb = qdisc_dequeue_peeked(cl->qdisc);
-	if (!skb) {
-		WARN_ONCE(1, "qfq_dequeue: non-workconserving leaf\n");
-		return NULL;
-	}
+/* Update F according to the actual service received by the aggregate. */
+static inline void charge_actual_service(struct qfq_sched *q,
+					 struct qfq_aggregate *agg)
+{
+	/* compute the service received by the aggregate */
+	u32 service_received = agg->initial_budget - agg->budget;
+	BUG_ON(qfq_gt(agg->S, q->V + (1ULL<<agg->grp->slot_shift)));
 
-	sch->q.qlen--;
-	qdisc_bstats_update(sch, skb);
 
-	old_V = q->V;
-	len = qdisc_pkt_len(skb);
-	q->V += (u64)len * IWSUM;
-	pr_debug("qfq dequeue: len %u F %lld now %lld\n",
-		 len, (unsigned long long) cl->F, (unsigned long long) q->V);
+	BUG_ON(agg->budget > agg->initial_budget);
 
-	if (qfq_update_class(grp, cl)) {
-		u64 old_F = grp->F;
+	BUG_ON(service_received > agg->initial_budget);
 
-		cl = qfq_slot_scan(grp);
-		if (!cl)
-			__clear_bit(grp->index, &q->bitmaps[ER]);
-		else {
-			u64 roundedS = qfq_round_down(cl->S, grp->slot_shift);
-			unsigned int s;
+	if (service_received > agg->budgetmax)
+		service_received = agg->budgetmax;
 
-			if (grp->S == roundedS)
-				goto skip_unblock;
-			grp->S = roundedS;
-			grp->F = roundedS + (2ULL << grp->slot_shift);
-			__clear_bit(grp->index, &q->bitmaps[ER]);
-			s = qfq_calc_state(q, grp);
-			__set_bit(grp->index, &q->bitmaps[s]);
-		}
 
-		qfq_unblock_groups(q, grp->index, old_F);
-	}
+	BUG_ON((u64)service_received * agg->inv_w >
+	       (1ULL<<agg->grp->slot_shift));
 
-skip_unblock:
-	qfq_update_eligible(q, old_V);
+	BUG_ON(qfq_gt(agg->F, q->V + (2ULL<<agg->grp->slot_shift)));
 
-	return skb;
+	agg->F = agg->S + (u64)service_received * agg->inv_w;
 }
 
 /*
- * Assign a reasonable start time for a new flow k in group i.
+ * Assign a reasonable start time for a new aggregate in group i.
  * Admissible values for \hat(F) are multiples of \sigma_i
  * no greater than V+\sigma_i . Larger values mean that
  * we had a wraparound so we consider the timestamp to be stale.
  *
  * If F is not stale and F >= V then we set S = F.
  * Otherwise we should assign S = V, but this may violate
- * the ordering in ER. So, if we have groups in ER, set S to
- * the F_j of the first group j which would be blocking us.
+ * the ordering in EB (see [2]). So, if we have groups in ER,
+ * set S to the F_j of the first group j which would be blocking us.
  * We are guaranteed not to move S backward because
  * otherwise our group i would still be blocked.
  */
-static void qfq_update_start(struct qfq_sched *q, struct qfq_class *cl)
+static void qfq_update_start(struct qfq_sched *q, struct qfq_aggregate *agg)
 {
 	unsigned long mask;
 	u64 limit, roundedF;
-	int slot_shift = cl->grp->slot_shift;
+	int slot_shift = agg->grp->slot_shift;
 
-	roundedF = qfq_round_down(cl->F, slot_shift);
+
+	roundedF = qfq_round_down(agg->F, slot_shift);
 	limit = qfq_round_down(q->V, slot_shift) + (1ULL << slot_shift);
 
-	if (!qfq_gt(cl->F, q->V) || qfq_gt(roundedF, limit)) {
+	if (!qfq_gt(agg->F, q->V) || qfq_gt(roundedF, limit)) {
 		/* timestamp was stale */
-		mask = mask_from(q->bitmaps[ER], cl->grp->index);
+		mask = mask_from(q->bitmaps[ER], agg->grp->index);
 		if (mask) {
 			struct qfq_group *next = qfq_ffs(q, mask);
 			if (qfq_gt(roundedF, next->F)) {
 				if (qfq_gt(limit, next->F))
-					cl->S = next->F;
+					agg->S = next->F;
 				else /* preserve timestamp correctness */
-					cl->S = limit;
+					agg->S = limit;
 				return;
 			}
 		}
-		cl->S = q->V;
-	} else  /* timestamp is not stale */
-		cl->S = cl->F;
+		agg->S = q->V;
+	} else { /* timestamp is not stale */
+		agg->S = agg->F;
+		BUG_ON(qfq_gt(agg->S, q->V + (2ULL << slot_shift)));
+
+	}
+	BUG_ON(qfq_gt(agg->S, q->V + (2ULL<<slot_shift)));
+}
+
+/*
+ * Update the timestamps of agg before scheduling/rescheduling it for
+ * service.  In particular, assign to agg->F its maximum possible
+ * value, i.e., the virtual finish time with which the aggregate
+ * should be labeled if it used all its budget once in service.
+ */
+static inline void
+qfq_update_agg_ts(struct qfq_sched *q,
+		  struct qfq_aggregate *agg, enum update_reason reason)
+{
+
+	int slot_shift = agg->grp->slot_shift;
+
+	BUG_ON(qfq_gt((u64)agg->budgetmax * agg->inv_w, 1ULL<<slot_shift));
+
+	if(qfq_gt(agg->S, q->V +
+		  ((reason == enqueue ? 2ULL : 1ULL)<<slot_shift)))
+		printk("qfq_update_agg_ts agg->S %llu limit %llu %s",
+		       (agg->S)>>slot_shift, (q->V>>slot_shift)+1,
+			reason==requeue ? "requeue" : "enqueue");
+
+	BUG_ON(qfq_gt(agg->S, q->V +
+		      ((reason == enqueue ? 2ULL : 1ULL)<<slot_shift)));
+
+	if (reason != requeue)
+		qfq_update_start(q, agg);
+	else {/* just charge agg for the service received */
+		BUG_ON(qfq_gt(agg->F, q->V + (2ULL<<slot_shift)));
+		agg->S = agg->F;
+	}
+
+	if (qfq_gt(agg->S, q->V + (2ULL<<slot_shift)))
+		printk("qfq_update_agg_ts S-V %llu %s",
+		       (agg->S - q->V)>>slot_shift,
+		       reason==requeue ? "requeue" : "enqueue");
+
+	BUG_ON(qfq_gt(agg->S, q->V + (2ULL<<slot_shift)));
+
+	agg->F = agg->S + (u64)agg->budgetmax * agg->inv_w;
+	BUG_ON(qfq_gt(agg->F, q->V + (3ULL<<slot_shift)));
+
+}
+
+static void qfq_schedule_agg(struct qfq_sched *, struct qfq_aggregate *);
+
+static struct sk_buff *qfq_dequeue(struct Qdisc *sch)
+{
+	struct qfq_sched *q = qdisc_priv(sch);
+	struct qfq_aggregate *in_serv_agg = q->in_serv_agg;
+	struct qfq_class *cl;
+	struct sk_buff *skb = NULL;
+	/* next-packet len, 0 means no more active classes in in-service agg */
+	unsigned int len = 0;
+
+	BUG_ON(in_serv_agg == NULL && qlen > 0);
+
+	if (in_serv_agg == NULL)
+		return NULL;
+
+	if (!list_empty(&in_serv_agg->active))
+		skb = qfq_peek_skb(in_serv_agg, &cl, &len);
+
+	BUG_ON(q->in_serv_agg == NULL && q->bitmaps[ER] == 0 &&
+	       qlen > 0);
+	BUG_ON(qfq_gt(in_serv_agg->grp->S,
+		      qfq_round_down(q->V, in_serv_agg->grp->slot_shift) +
+		      (2ULL << in_serv_agg->grp->slot_shift)));
+	/*
+	 * If there are no active classes in the in-service aggregate,
+	 * or if the aggregate has not enough budget to serve its next
+	 * class, then choose the next aggregate to serve.
+	 */
+	if (len == 0 || in_serv_agg->budget < len) {
+		charge_actual_service(q, in_serv_agg);
+
+		/* recharge the budget of the aggregate */
+		in_serv_agg->initial_budget = in_serv_agg->budget =
+			in_serv_agg->budgetmax;
+
+		if (!list_empty(&in_serv_agg->active)) {
+			/*
+			 * Still active: reschedule for
+			 * service. Possible optimization: if no other
+			 * aggregate is active, then there is no point
+			 * in rescheduling this aggregate, and we can
+			 * just keep it as the in-service one. This
+			 * should be however a corner case, and to
+			 * handle it, we would need to maintain an
+			 * extra num_active_aggs field.
+			*/
+			BUG_ON(qfq_gt(q->V -
+				      (2ULL << in_serv_agg->grp->slot_shift),
+				      in_serv_agg->S));
+
+			BUG_ON(qfq_gt(in_serv_agg->S, q->V +
+				      (1ULL << in_serv_agg->grp->slot_shift)));
+
+			qfq_update_agg_ts(q, in_serv_agg, requeue);
+
+			BUG_ON(qfq_gt(q->V -
+				      (2ULL << in_serv_agg->grp->slot_shift),
+				      in_serv_agg->S));
+			BUG_ON(qfq_gt(in_serv_agg->S, q->V +
+				      (2ULL << in_serv_agg->grp->slot_shift)));
+
+			qfq_schedule_agg(q, in_serv_agg);
+		} else if (sch->q.qlen == 0) { /* no aggregate to serve */
+			q->in_serv_agg = NULL;
+			return NULL;
+		}
+
+		/*
+		 * If we get here, there are other aggregates queued:
+		 * choose the new aggregate to serve.
+		 */
+		in_serv_agg = q->in_serv_agg = qfq_choose_next_agg(q);
+		
+		BUG_ON(in_serv_agg == NULL);
+		BUG_ON(qfq_gt(in_serv_agg->S, q->V +
+			      (1ULL << in_serv_agg->grp->slot_shift)));
+
+		skb = qfq_peek_skb(in_serv_agg, &cl, &len);
+	}
+	if (!skb)
+		return NULL;
+
+	sch->q.qlen--;
+	qlen--;
+
+	qdisc_bstats_update(sch, skb);
+
+	agg_dequeue(in_serv_agg, cl, len);
+	/*
+	 * The user may choose an lmax lower than the actual lmax
+	 */
+	if (unlikely(in_serv_agg->budget < len))
+		in_serv_agg->budget = 0;
+	else
+		in_serv_agg->budget -= len;
+	q->V += (u64)len * IWSUM;
+	BUG_ON(qfq_gt(in_serv_agg->grp->S,
+		      qfq_round_down(q->V, in_serv_agg->grp->slot_shift) +
+		      (2ULL << in_serv_agg->grp->slot_shift)));
+	BUG_ON(q->V != q->oldV &&
+	       fls((q->V>>q->min_slot_shift) ^
+		   (q->oldV>>q->min_slot_shift)) >
+	       QFQ_MAX_INDEX);
+	
+	pr_debug("qfq dequeue: len %u F %lld now %lld\n",
+		 len, (unsigned long long) in_serv_agg->F,
+		 (unsigned long long) q->V);
+
+	return skb;
+}
+
+static struct qfq_aggregate *qfq_choose_next_agg(struct qfq_sched *q)
+{
+	struct qfq_group *grp;
+	struct qfq_aggregate *agg, *new_front_agg;
+	u64 old_F;
+
+	qfq_update_eligible(q);
+	q->oldV = q->V;
+
+	BUG_ON(q->bitmaps[ER] == 0 && qlen > 0 && q->in_serv_agg == NULL);
+
+	if (!q->bitmaps[ER])
+		return NULL;
+
+	grp = qfq_ffs(q, q->bitmaps[ER]);
+	old_F = grp->F;
+
+	agg = qfq_slot_head(grp);
+	BUG_ON(agg == NULL);
+	BUG_ON(list_empty(&agg->active));
+	BUG_ON(qfq_gt(agg->S, q->V + (1ULL<<agg->grp->slot_shift)));
+	BUG_ON(qfq_gt(grp->S, q->V));
+	
+	/* agg starts to be served, remove it from schedule */
+	qfq_front_slot_remove(grp);
+
+	new_front_agg = qfq_slot_scan(grp);
+	BUG_ON(new_front_agg == agg);
+	BUG_ON(new_front_agg != NULL && list_empty(&new_front_agg->active));
+
+	if (new_front_agg == NULL) /* group is now inactive, remove from ER */
+		__clear_bit(grp->index, &q->bitmaps[ER]);
+	else {
+		u64 roundedS = qfq_round_down(new_front_agg->S,
+					      grp->slot_shift);
+		unsigned int s;
+		int i;
+
+		if (grp->S == roundedS)
+			return agg;
+		grp->S = roundedS;
+		BUG_ON(qfq_gt(agg->grp->S,
+			      qfq_round_down(q->V, agg->grp->slot_shift) +
+			      (2ULL << agg->grp->slot_shift)));
+		
+		grp->F = roundedS + (2ULL << grp->slot_shift);
+		__clear_bit(grp->index, &q->bitmaps[ER]);
+		s = qfq_calc_state(q, grp);
+		__set_bit(grp->index, &q->bitmaps[s]);
+		BUG_ON((test_bit(grp->index, &q->bitmaps[ER]) ||
+			test_bit(grp->index, &q->bitmaps[EB]))
+		       && qfq_gt(grp->S, q->V));
+		BUG_ON((test_bit(grp->index, &q->bitmaps[IR]) ||
+			test_bit(grp->index, &q->bitmaps[IB]))
+		       &&
+		       qfq_gt(grp->S, q->V + (1ULL<<grp->slot_shift)));
+
+		for (i = 0; i <= QFQ_MAX_INDEX; i++) {
+			struct qfq_group *grp = &q->groups[i];
+			BUG_ON((test_bit(grp->index, &q->bitmaps[ER]) ||
+				test_bit(grp->index, &q->bitmaps[EB]))
+			       && qfq_gt(grp->S, q->V));
+			BUG_ON((test_bit(grp->index, &q->bitmaps[IR]) ||
+				test_bit(grp->index, &q->bitmaps[IB]))
+			       &&
+			       qfq_gt(grp->S, q->V + (1ULL<<grp->slot_shift)));
+		}
+
+	}
+
+	qfq_unblock_groups(q, grp->index, old_F);
+
+	return agg;
 }
 
 static int qfq_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 {
 	struct qfq_sched *q = qdisc_priv(sch);
 	struct qfq_class *cl;
+	struct qfq_aggregate *agg;
 	int err = 0;
 
+	BUG_ON(q->in_serv_agg == NULL && qlen > 0);
 	cl = qfq_classify(skb, sch, &err);
 	if (cl == NULL) {
 		if (err & __NET_XMIT_BYPASS)
@@ -934,11 +1420,13 @@ static int qfq_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 	}
 	pr_debug("qfq_enqueue: cl = %x\n", cl->common.classid);
 
-	if (unlikely(cl->lmax < qdisc_pkt_len(skb))) {
+	if (unlikely(cl->agg->lmax < qdisc_pkt_len(skb))) {
 		pr_debug("qfq: increasing maxpkt from %u to %u for class %u",
-			  cl->lmax, qdisc_pkt_len(skb), cl->common.classid);
-		qfq_update_reactivate_class(q, cl, cl->inv_w,
-					    qdisc_pkt_len(skb), 0);
+			 cl->agg->lmax, qdisc_pkt_len(skb), cl->common.classid);
+		err = qfq_change_agg(sch, cl, cl->agg->class_weight,
+				     qdisc_pkt_len(skb));
+		if (err)
+			return err;
 	}
 
 	err = qdisc_enqueue(skb, cl->qdisc);
@@ -953,36 +1441,57 @@ static int qfq_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 
 	bstats_update(&cl->bstats, skb);
 	++sch->q.qlen;
+	qlen++;
+
+	agg = cl->agg;
+	/* if the queue was not empty, then done here */
+	if (cl->qdisc->q.qlen != 1) {
+		if (unlikely(skb == cl->qdisc->ops->peek(cl->qdisc)) &&
+		    list_first_entry(&agg->active, struct qfq_class, alist)
+		    == cl && cl->deficit < qdisc_pkt_len(skb))
+			list_move_tail(&cl->alist, &agg->active);
 
-	/* If the new skb is not the head of queue, then done here. */
-	if (cl->qdisc->q.qlen != 1)
 		return err;
+	}
+
+	/* schedule class for service within the aggregate */
+	cl->deficit = agg->lmax;
+	list_add_tail(&cl->alist, &agg->active);
 
-	/* If reach this point, queue q was idle */
-	qfq_activate_class(q, cl, qdisc_pkt_len(skb));
+	BUG_ON(qdisc_pkt_len(skb) > agg->lmax);
+	if (list_first_entry(&agg->active, struct qfq_class, alist) != cl ||
+	    q->in_serv_agg == agg)
+		return err; /* 
+			     * aggregate was in service or not empty,
+			     * nothing else to do
+			     */
 
+
+	BUG_ON(qfq_gt(agg->S, q->V + (2ULL << agg->grp->slot_shift)));
+
+	qfq_activate_agg(q, agg, enqueue);
+	BUG_ON(qfq_gt(agg->grp->S,
+		      qfq_round_down(q->V, agg->grp->slot_shift) +
+		      (2ULL << agg->grp->slot_shift)));
+	
 	return err;
 }
 
 /*
- * Handle class switch from idle to backlogged.
+ * Schedule aggregate according to its timestamps.
  */
-static void qfq_activate_class(struct qfq_sched *q, struct qfq_class *cl,
-			       unsigned int pkt_len)
+static void qfq_schedule_agg(struct qfq_sched *q, struct qfq_aggregate *agg)
 {
-	struct qfq_group *grp = cl->grp;
+	struct qfq_group *grp = agg->grp;
 	u64 roundedS;
 	int s;
+	int i;
 
-	qfq_update_start(q, cl);
-
-	/* compute new finish time and rounded start. */
-	cl->F = cl->S + (u64)pkt_len * cl->inv_w;
-	roundedS = qfq_round_down(cl->S, grp->slot_shift);
-
+	roundedS = qfq_round_down(agg->S, grp->slot_shift);
+	BUG_ON(qfq_gt(roundedS, q->V + (1ULL<<grp->slot_shift)));
 	/*
-	 * insert cl in the correct bucket.
-	 * If cl->S >= grp->S we don't need to adjust the
+	 * Insert agg in the correct bucket.
+	 * If agg->S >= grp->S we don't need to adjust the
 	 * bucket list and simply go to the insertion phase.
 	 * Otherwise grp->S is decreasing, we must make room
 	 * in the bucket list, and also recompute the group state.
@@ -990,64 +1499,139 @@ static void qfq_activate_class(struct qfq_sched *q, struct qfq_class *cl,
 	 * was in ER make sure to adjust V.
 	 */
 	if (grp->full_slots) {
-		if (!qfq_gt(grp->S, cl->S))
+		if (!qfq_gt(grp->S, agg->S))
 			goto skip_update;
 
-		/* create a slot for this cl->S */
-		qfq_slot_rotate(grp, roundedS);
+		/* create a slot for this agg->S */
+		qfq_slot_rotate(grp, roundedS, q);
 		/* group was surely ineligible, remove */
 		__clear_bit(grp->index, &q->bitmaps[IR]);
 		__clear_bit(grp->index, &q->bitmaps[IB]);
-	} else if (!q->bitmaps[ER] && qfq_gt(roundedS, q->V))
+	} else if (!q->bitmaps[ER] && qfq_gt(roundedS, q->V) &&
+		   q->in_serv_agg == NULL)
 		q->V = roundedS;
 
+	BUG_ON(q->V != q->oldV &&
+	       fls((q->V>>q->min_slot_shift) ^
+		   (q->oldV>>q->min_slot_shift)) >
+	       QFQ_MAX_INDEX);
+	
 	grp->S = roundedS;
+	BUG_ON(qfq_gt(agg->grp->S,
+		      qfq_round_down(q->V, agg->grp->slot_shift) +
+		      (2ULL << agg->grp->slot_shift)));
+	
 	grp->F = roundedS + (2ULL << grp->slot_shift);
 	s = qfq_calc_state(q, grp);
 	__set_bit(grp->index, &q->bitmaps[s]);
+	BUG_ON((test_bit(grp->index, &q->bitmaps[ER]) ||
+		test_bit(grp->index, &q->bitmaps[EB]))
+	       && qfq_gt(grp->S, q->V));
+	BUG_ON((test_bit(grp->index, &q->bitmaps[IR]) ||
+		test_bit(grp->index, &q->bitmaps[IB]))
+	       &&
+	       qfq_gt(grp->S, q->V + (1ULL<<grp->slot_shift)));
+	
+	for (i = 0; i <= QFQ_MAX_INDEX; i++) {
+		struct qfq_group *grp = &q->groups[i];
+		BUG_ON((test_bit(grp->index, &q->bitmaps[ER]) ||
+			test_bit(grp->index, &q->bitmaps[EB]))
+		       && qfq_gt(grp->S, q->V));
+		BUG_ON((test_bit(grp->index, &q->bitmaps[IR]) ||
+			test_bit(grp->index, &q->bitmaps[IB]))
+		       &&
+		       qfq_gt(grp->S, q->V + (1ULL<<grp->slot_shift)));
+	}
 
 	pr_debug("qfq enqueue: new state %d %#lx S %lld F %lld V %lld\n",
 		 s, q->bitmaps[s],
-		 (unsigned long long) cl->S,
-		 (unsigned long long) cl->F,
+		 (unsigned long long) agg->S,
+		 (unsigned long long) agg->F,
 		 (unsigned long long) q->V);
 
 skip_update:
-	qfq_slot_insert(grp, cl, roundedS);
+	BUG_ON(qfq_gt(agg->S,
+		      q->V + (2ULL << agg->grp->slot_shift)));
+
+	qfq_slot_insert(grp, agg, roundedS, q);
+	BUG_ON((q->bitmaps[ER] | q->bitmaps[IR] | q->bitmaps[IB]) == 0 &&
+	       qlen > 0 && q->in_serv_agg == NULL);
+
+
 }
 
 
+/* Update agg ts and schedule agg for service */
+static void qfq_activate_agg(struct qfq_sched *q, struct qfq_aggregate *agg,
+			     enum update_reason reason)
+{
+	BUG_ON(list_empty(&agg->active));
+
+	agg->initial_budget = agg->budget = agg->budgetmax;
+
+	qfq_update_agg_ts(q, agg, reason);
+	if (q->in_serv_agg == NULL) {
+		q->in_serv_agg = agg;
+		BUG_ON((q->bitmaps[ER] | q->bitmaps[EB] | q->bitmaps[IR] | 
+			q->bitmaps[IB]) != 0);
+		/* no agg scheduled, push V up */
+		q->oldV = q->V = agg->S;
+	}
+	else if (agg != q->in_serv_agg)
+		qfq_schedule_agg(q, agg);
+	
+	BUG_ON((q->bitmaps[ER] | q->bitmaps[IR] | q->bitmaps[IB]) == 0 &&
+	       qlen > 0 && q->in_serv_agg == NULL);
+}
+
 static void qfq_slot_remove(struct qfq_sched *q, struct qfq_group *grp,
-			    struct qfq_class *cl)
+			    struct qfq_aggregate *agg)
 {
 	unsigned int i, offset;
 	u64 roundedS;
 
-	roundedS = qfq_round_down(cl->S, grp->slot_shift);
+	BUG_ON((q->bitmaps[ER] | q->bitmaps[IR] | q->bitmaps[IB]) == 0 &&
+	       qlen > 0 && q->in_serv_agg == NULL);
+
+	roundedS = qfq_round_down(agg->S, grp->slot_shift);
 	offset = (roundedS - grp->S) >> grp->slot_shift;
+
+	BUG_ON(offset >= QFQ_MAX_SLOTS);
+
 	i = (grp->front + offset) % QFQ_MAX_SLOTS;
 
-	hlist_del(&cl->next);
+	hlist_del(&agg->next);
 	if (hlist_empty(&grp->slots[i]))
 		__clear_bit(offset, &grp->full_slots);
 }
 
 /*
- * called to forcibly destroy a queue.
- * If the queue is not in the front bucket, or if it has
- * other queues in the front bucket, we can simply remove
- * the queue with no other side effects.
+ * Called to forcibly deschedule an aggregate.  If the aggregate is
+ * not in the front bucket, or if the latter has other aggregates in
+ * the front bucket, we can simply remove the aggregate with no other
+ * side effects.
  * Otherwise we must propagate the event up.
  */
-static void qfq_deactivate_class(struct qfq_sched *q, struct qfq_class *cl)
+static void qfq_deactivate_agg(struct qfq_sched *q, struct qfq_aggregate *agg)
 {
-	struct qfq_group *grp = cl->grp;
+	struct qfq_group *grp = agg->grp;
 	unsigned long mask;
 	u64 roundedS;
 	int s;
 
-	cl->F = cl->S;
-	qfq_slot_remove(q, grp, cl);
+	BUG_ON((q->bitmaps[ER] | q->bitmaps[IR] | q->bitmaps[IB]) == 0 &&
+	       qlen > 0 && q->in_serv_agg == NULL);
+
+	if (agg == q->in_serv_agg) {
+		charge_actual_service(q, agg);
+		q->in_serv_agg = qfq_choose_next_agg(q);
+
+		return;
+	}
+
+	agg->F = agg->S;
+	BUG_ON(qfq_gt(agg->F, q->V + (2ULL << agg->grp->slot_shift)));
+	qfq_slot_remove(q, grp, agg);
 
 	if (!grp->full_slots) {
 		__clear_bit(grp->index, &q->bitmaps[IR]);
@@ -1066,8 +1650,9 @@ static void qfq_deactivate_class(struct qfq_sched *q, struct qfq_class *cl)
 		}
 		__clear_bit(grp->index, &q->bitmaps[ER]);
 	} else if (hlist_empty(&grp->slots[grp->front])) {
-		cl = qfq_slot_scan(grp);
-		roundedS = qfq_round_down(cl->S, grp->slot_shift);
+		agg = qfq_slot_scan(grp);
+
+		roundedS = qfq_round_down(agg->S, grp->slot_shift);
 		if (grp->S != roundedS) {
 			__clear_bit(grp->index, &q->bitmaps[ER]);
 			__clear_bit(grp->index, &q->bitmaps[IR]);
@@ -1077,10 +1662,16 @@ static void qfq_deactivate_class(struct qfq_sched *q, struct qfq_class *cl)
 			grp->F = roundedS + (2ULL << grp->slot_shift);
 			s = qfq_calc_state(q, grp);
 			__set_bit(grp->index, &q->bitmaps[s]);
+			BUG_ON((test_bit(grp->index, &q->bitmaps[ER]) ||
+				test_bit(grp->index, &q->bitmaps[EB]))
+			       && qfq_gt(grp->S, q->V));
+			BUG_ON((test_bit(grp->index, &q->bitmaps[IR]) ||
+				test_bit(grp->index, &q->bitmaps[IB]))
+			       &&
+			       qfq_gt(grp->S, q->V + (1ULL<<grp->slot_shift)));
+			
 		}
 	}
-
-	qfq_update_eligible(q, q->V);
 }
 
 static void qfq_qlen_notify(struct Qdisc *sch, unsigned long arg)
@@ -1092,6 +1683,32 @@ static void qfq_qlen_notify(struct Qdisc *sch, unsigned long arg)
 		qfq_deactivate_class(q, cl);
 }
 
+static unsigned int qfq_drop_from_slot(struct qfq_sched *q,
+				       struct hlist_head *slot)
+{
+	struct qfq_aggregate *agg;
+	struct hlist_node *n;
+	struct qfq_class *cl;
+	unsigned int len;
+
+	hlist_for_each_entry(agg, n, slot, next) {
+		list_for_each_entry(cl, &agg->active, alist) {
+
+			if (!cl->qdisc->ops->drop)
+				continue;
+
+			len = cl->qdisc->ops->drop(cl->qdisc);
+			if (len > 0) {
+				if (cl->qdisc->q.qlen == 0)
+					qfq_deactivate_class(q, cl);
+
+				return len;
+			}
+		}
+	}
+	return 0;
+}
+
 static unsigned int qfq_drop(struct Qdisc *sch)
 {
 	struct qfq_sched *q = qdisc_priv(sch);
@@ -1101,26 +1718,15 @@ static unsigned int qfq_drop(struct Qdisc *sch)
 	for (i = 0; i <= QFQ_MAX_INDEX; i++) {
 		grp = &q->groups[i];
 		for (j = 0; j < QFQ_MAX_SLOTS; j++) {
-			struct qfq_class *cl;
-			struct hlist_node *n;
-
-			hlist_for_each_entry(cl, n, &grp->slots[j], next) {
-
-				if (!cl->qdisc->ops->drop)
-					continue;
-
-				len = cl->qdisc->ops->drop(cl->qdisc);
-				if (len > 0) {
-					sch->q.qlen--;
-					if (!cl->qdisc->q.qlen)
-						qfq_deactivate_class(q, cl);
-
-					return len;
-				}
+			len = qfq_drop_from_slot(q, &grp->slots[j]);
+			if (len > 0) {
+				sch->q.qlen--;
+				qlen--;
+				return len;
 			}
 		}
-	}
 
+	}
 	return 0;
 }
 
@@ -1129,44 +1735,53 @@ static int qfq_init_qdisc(struct Qdisc *sch, struct nlattr *opt)
 	struct qfq_sched *q = qdisc_priv(sch);
 	struct qfq_group *grp;
 	int i, j, err;
+	u32 max_cl_shift, maxbudg_shift, max_classes;
 
 	err = qdisc_class_hash_init(&q->clhash);
 	if (err < 0)
 		return err;
 
+	if (qdisc_dev(sch)->tx_queue_len + 1 > QFQ_MAX_AGG_CLASSES)
+		max_classes = QFQ_MAX_AGG_CLASSES;
+	else
+		max_classes = qdisc_dev(sch)->tx_queue_len + 1;
+	/* max_cl_shift = floor(log_2(max_classes)) */
+	max_cl_shift = __fls(max_classes);
+	q->max_agg_classes = 1<<max_cl_shift;
+
+	/* maxbudg_shift = log2(max_len * max_classes_per_agg) */
+	maxbudg_shift = QFQ_MTU_SHIFT + max_cl_shift;
+	q->min_slot_shift = FRAC_BITS + maxbudg_shift - QFQ_MAX_INDEX;
+
 	for (i = 0; i <= QFQ_MAX_INDEX; i++) {
 		grp = &q->groups[i];
 		grp->index = i;
-		grp->slot_shift = QFQ_MTU_SHIFT + FRAC_BITS
-				   - (QFQ_MAX_INDEX - i);
+		grp->slot_shift = q->min_slot_shift + i;
+		BUG_ON(grp->slot_shift > 63);
 		for (j = 0; j < QFQ_MAX_SLOTS; j++)
 			INIT_HLIST_HEAD(&grp->slots[j]);
 	}
 
+	INIT_HLIST_HEAD(&q->nonfull_aggs);
+
 	return 0;
 }
 
 static void qfq_reset_qdisc(struct Qdisc *sch)
 {
 	struct qfq_sched *q = qdisc_priv(sch);
-	struct qfq_group *grp;
 	struct qfq_class *cl;
-	struct hlist_node *n, *tmp;
-	unsigned int i, j;
+	struct hlist_node *n;
+	unsigned int i;
 
-	for (i = 0; i <= QFQ_MAX_INDEX; i++) {
-		grp = &q->groups[i];
-		for (j = 0; j < QFQ_MAX_SLOTS; j++) {
-			hlist_for_each_entry_safe(cl, n, tmp,
-						  &grp->slots[j], next) {
+	qlen = 0;
+	for (i = 0; i < q->clhash.hashsize; i++) {
+		hlist_for_each_entry(cl, n, &q->clhash.hash[i], common.hnode) {
+			if (cl->qdisc->q.qlen > 0)
 				qfq_deactivate_class(q, cl);
-			}
-		}
-	}
 
-	for (i = 0; i < q->clhash.hashsize; i++) {
-		hlist_for_each_entry(cl, n, &q->clhash.hash[i], common.hnode)
 			qdisc_reset(cl->qdisc);
+		}
 	}
 	sch->q.qlen = 0;
 }
-- 
1.7.9.5

